{"version":3,"file":"sw-z2SR8lXJ.js","sources":["src/config/modes.ts","src/config/debug.ts","src/environment/ctx.ts","src/environment/userAgent.ts","src/helpers/context.ts","src/helpers/dT.ts","src/lib/logger.ts","src/helpers/schedulers/pause.ts","src/lib/serviceWorker/cache.ts","src/helpers/blob/readBlobAs.ts","src/helpers/blob/readBlobAsArrayBuffer.ts","src/helpers/blob/readBlobAsUint8Array.ts","src/helpers/noop.ts","src/helpers/cancellablePromise.ts","src/helpers/bytes/bytesFromHex.ts","src/helpers/bytes/bytesCmp.ts","src/helpers/fixChromiumMp4.ts","src/helpers/schedulers/debounce.ts","src/helpers/blob/blobSafeMimeType.ts","src/helpers/blob/blobConstruct.ts","src/lib/files/memoryWriter.ts","src/helpers/makeError.ts","src/lib/files/cacheStorage.ts","src/lib/serviceWorker/timeout.ts","src/lib/serviceWorker/stream.ts","src/config/databases/state.ts","src/config/notifications.ts","src/helpers/object/deepEqual.ts","src/helpers/object/safeAssign.ts","src/lib/files/idb.ts","src/lib/serviceWorker/push.ts","src/config/tabId.ts","src/helpers/array/indexOfAndSplice.ts","src/helpers/eventListenerBase.ts","src/lib/mtproto/superMessagePort.ts","src/lib/serviceWorker/serviceMessagePort.ts","src/helpers/listenMessagePort.ts","src/lib/serviceWorker/download.ts","src/lib/serviceWorker/share.ts","src/lib/serviceWorker/index.service.ts"],"sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type {TransportType} from '../lib/mtproto/dcConfigurator';\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  asServiceWorker: !!import.meta.env.VITE_MTPROTO_SW,\n  transport: 'websocket' as TransportType,\n  noSharedWorker: location.search.indexOf('noSharedWorker=1') > 0,\n  multipleTransports: !!(import.meta.env.VITE_MTPROTO_AUTO && import.meta.env.VITE_MTPROTO_HAS_HTTP && import.meta.env.VITE_MTPROTO_HAS_WS)\n};\n\nif(import.meta.env.VITE_MTPROTO_HAS_HTTP) {\n  const httpOnly = Modes.http = location.search.indexOf('http=1') > 0;\n  if(httpOnly) {\n    Modes.multipleTransports = false;\n  }\n}\n\n// * start with HTTP first\nif(Modes.multipleTransports) {\n  Modes.http = true;\n}\n\nif(Modes.http) {\n  Modes.transport = 'https';\n}\n\nexport default Modes;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from './modes';\n\nexport const IS_BETA = import.meta.env.DEV;\nexport const DEBUG = (IS_BETA || Modes.debug)/*  && false */;\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\nexport default DEBUG;\n\n// let m = DEBUG;\n/* if(!DEBUG) {\n  ctx.sandpitTurtle = () => {\n    //if(!m) {\n      for(let i in MOUNT_CLASS_TO) {\n        ctx[i] = MOUNT_CLASS_TO[i];\n      }\n      //m = true;\n    //}\n\n    //DEBUG = !DEBUG;\n  };\n} */\n\n/* export const superDebug = (object: any, key: string) => {\n  var d = object[key];\n  var beforeStr = '', afterStr = '';\n  for(var r of d) {\n    beforeStr += r.before.hex + '\\n';\n    afterStr += r.after.hex + '\\n';\n  }\n\n  beforeStr = beforeStr.trim();\n  afterStr = afterStr.trim();\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\n\n  var dada = (name: string, str: string) => {\n    var a = document.createElement('a');\n    a.target = '_blank';\n    a.download = name + '.txt';\n    a.href = URL.createObjectURL(new Blob([str], {\n      type: 'text/plain'\n    }));\n    document.body.append(a);\n    a.click();\n  };\n\n  dada(key + '_' + 'before', beforeStr);\n  dada(key + '_' + 'after', afterStr);\n}\n\nMOUNT_CLASS_TO.superDebug = superDebug; */\n","const ctx = typeof(window) !== 'undefined' ? window : self;\n\nexport default ctx;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport ctx from './ctx';\n\nexport const USER_AGENT = navigator ? navigator.userAgent : null;\nexport const IS_APPLE = navigator.userAgent.search(/OS X|iPhone|iPad|iOS/i) !== -1;\nexport const IS_ANDROID = navigator.userAgent.toLowerCase().indexOf('android') !== -1;\nexport const IS_CHROMIUM = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\nexport const CHROMIUM_VERSION = (() => {\n  try {\n    return +navigator.userAgent.match(/Chrom(?:e|ium)\\/(.+?)(?:\\s|\\.)/)[1];\n  } catch(err) {\n  }\n})();\n\n// https://stackoverflow.com/a/58065241\nexport const IS_APPLE_MOBILE = (/iPad|iPhone|iPod/.test(navigator.platform) ||\n  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&\n  !(ctx as any).MSStream;\n\nexport const IS_SAFARI = !!('safari' in ctx) || !!(USER_AGENT && (/\\b(iPad|iPhone|iPod)\\b/.test(USER_AGENT) || (!!USER_AGENT.match('Safari') && !USER_AGENT.match('Chrome'))))/*  || true */;\nexport const IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\nexport const IS_MOBILE_SAFARI = IS_SAFARI && IS_APPLE_MOBILE;\n\nexport const IS_MOBILE = (navigator.maxTouchPoints === undefined || navigator.maxTouchPoints > 0) && navigator.userAgent.search(/iOS|iPhone OS|Android|BlackBerry|BB10|Series ?[64]0|J2ME|MIDP|opera mini|opera mobi|mobi.+Gecko|Windows Phone/i) != -1;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// в SW может быть сразу две переменных TRUE\nexport const IS_SERVICE_WORKER = typeof ServiceWorkerGlobalScope !== 'undefined' && self instanceof ServiceWorkerGlobalScope;\nexport const IS_WEB_WORKER = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && !IS_SERVICE_WORKER;\nexport const IS_WORKER = IS_WEB_WORKER || IS_SERVICE_WORKER;\n\nexport const getWindowClients = () => {\n  return (self as any as ServiceWorkerGlobalScope)\n  .clients\n  .matchAll({includeUncontrolled: false, type: 'window'});\n};\n\nexport const getLastWindowClient = () => getWindowClients().then((windowClients) => windowClients.slice(-1)[0]);\n\nconst postMessage = (listener: WindowClient | DedicatedWorkerGlobalScope, ...args: any[]) => {\n  try {\n    // @ts-ignore\n    listener.postMessage(...args);\n  } catch(err) {\n    console.error('[worker] postMessage error:', err, args);\n  }\n};\n\nconst notifyServiceWorker = (all: boolean, ...args: any[]) => {\n  getWindowClients().then((listeners) => {\n    if(!listeners.length) {\n      // console.trace('no listeners?', self, listeners);\n      return;\n    }\n\n    listeners.slice(all ? 0 : -1).forEach((listener) => {\n      postMessage(listener, ...args);\n    });\n  });\n};\n\nconst notifyWorker = (...args: any[]) => {\n  postMessage(self as any as DedicatedWorkerGlobalScope, ...args);\n};\n\nconst noop = () => {};\n\nexport const notifySomeone = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, false) : (IS_WEB_WORKER ? notifyWorker : noop);\nexport const notifyAll = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, true) : (IS_WEB_WORKER ? notifyWorker : noop);\n","const _logTimer = Date.now();\nexport default function dT() {\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from '../config/debug';\nimport {IS_FIREFOX, IS_SAFARI} from '../environment/userAgent';\nimport {IS_SERVICE_WORKER, IS_WEB_WORKER} from '../helpers/context';\nimport dT from '../helpers/dT';\n\nexport enum LogTypes {\n  None = 0,\n  Error = 1,\n  Warn = 2,\n  Log = 4,\n  Debug = 8\n};\n\nexport const LOG_LEVELS = [LogTypes.None, LogTypes.Error, LogTypes.Warn, LogTypes.Log, LogTypes.Debug];\n\nconst IS_WEBKIT = IS_SAFARI || IS_FIREFOX;\n\n// let getCallerFunctionNameFromLine: (line: string) => string;\n// if(IS_WEBKIT) {\n//   getCallerFunctionNameFromLine = (line) => {\n//     const splitted = line.split('@');\n//     return splitted[0];\n//   };\n// } else {\n//   getCallerFunctionNameFromLine = (line: string) => {\n//     const splitted = line.trim().split(' ');\n//     if(splitted.length === 3) {\n//       return splitted[1].slice(splitted[1].lastIndexOf('.') + 1);\n//     }\n//   };\n// }\n\nconst STYLES_SUPPORTED = !IS_WEBKIT;\n// const LINE_INDEX = IS_WEBKIT ? 2 : 3;\n\n// function getCallerFunctionName() {\n//   const stack = new Error().stack;\n//   const lines = stack.split('\\n');\n//   const line = lines[LINE_INDEX] || lines[lines.length - 1];\n//   // const match = line.match(/\\.([^\\.]+?)\\s/);\n//   // line = match ? match[1] : line.trim();\n//   const caller = getCallerFunctionNameFromLine(line) || '<anonymous>';\n//   return '[' + caller + ']';\n// }\n\nexport const LOGGER_STYLES = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  underscore: '\\x1b[4m',\n  blink: '\\x1b[5m',\n  reverse: '\\x1b[7m',\n  hidden: '\\x1b[8m',\n  // Foreground (text) colors\n  fg: {\n    black: '\\x1b[30m',\n    red: '\\x1b[31m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m',\n    white: '\\x1b[37m'\n  },\n  // Background colors\n  bg: {\n    black: '\\x1b[40m',\n    red: '\\x1b[41m',\n    green: '\\x1b[42m',\n    yellow: '\\x1b[43m',\n    blue: '\\x1b[44m',\n    magenta: '\\x1b[45m',\n    cyan: '\\x1b[46m',\n    white: '\\x1b[47m'\n  }\n};\n\nexport type Logger = {\n  (...args: any[]): void;\n  warn(...args: any[]): void;\n  info(...args: any[]): void;\n  error(...args: any[]): void;\n  trace(...args: any[]): void;\n  debug(...args: any[]): void;\n  assert(...args: any[]): void;\n  // log(...args: any[]): void;\n  group(...args: any[]): void;\n  groupCollapsed(...args: any[]): void;\n  groupEnd(...args: any[]): void;\n  setPrefix(newPrefix: string): void;\n  setLevel(level: 0 | 1 | 2 | 3 | 4): void;\n  bindPrefix(prefix: string, type?: LogTypes): Logger;\n};\n\nconst methods: ['debug' | 'info' | 'warn' | 'error' | 'assert' | 'trace'/*  | 'log' */ | 'group' | 'groupCollapsed' | 'groupEnd', LogTypes][] = [\n  ['debug', LogTypes.Debug],\n  ['info', LogTypes.Log],\n  ['warn', LogTypes.Warn],\n  ['error', LogTypes.Error],\n  ['assert', LogTypes.Error],\n  ['trace', LogTypes.Log],\n  ['group', LogTypes.Log],\n  ['groupCollapsed', LogTypes.Log],\n  ['groupEnd', LogTypes.Log]\n  // [\"log\", LogTypes.Log]\n];\n\nexport function logger(prefix: string, type: LogTypes = LogTypes.Log | LogTypes.Warn | LogTypes.Error, ignoreDebugReset = false, style = ''): Logger {\n  let originalPrefix: string;\n  if(!DEBUG && !ignoreDebugReset/*  || true */) {\n    type = LogTypes.Error;\n  }\n\n  if(!STYLES_SUPPORTED) {\n    style = '';\n  } else if(!style) {\n    if(IS_SERVICE_WORKER) style = LOGGER_STYLES.fg.yellow;\n    else if(IS_WEB_WORKER) style = LOGGER_STYLES.fg.cyan;\n  }\n\n  const originalStyle = style;\n  if(style) style = `%s ${style}%s`;\n  else style = '%s';\n\n  // level = LogLevels.log | LogLevels.warn | LogLevels.error | LogLevels.debug\n\n  const log: Logger = function(...args: any[]) {\n    return type & LogTypes.Log && console.log(style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\n  } as any;\n\n  methods.forEach(([method, logType]) => {\n    log[method] = function(...args: any[]) {\n      return type & logType && console[method](style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\n    };\n  });\n\n  log.setPrefix = function(newPrefix: string) {\n    originalPrefix = newPrefix;\n    prefix = '[' + newPrefix + ']';\n  };\n\n  log.setPrefix(prefix);\n\n  log.setLevel = function(level: 0 | 1 | 2 | 3 | 4) {\n    type = LOG_LEVELS.slice(0, level + 1).reduce((acc, v) => acc | v, 0) as any;\n  };\n\n  const prefixCache: {[prefix: string]: Logger} = {};\n  log.bindPrefix = function(prefix: string, _type = type) {\n    return prefixCache[prefix] ??= logger(\n      // `${originalPrefix}] ${LOGGER_STYLES.fg.magenta}[${prefix}`,\n      `${originalPrefix}] ${STYLES_SUPPORTED && originalStyle ? LOGGER_STYLES.reset : ''}[${prefix}`,\n      // `${originalPrefix}] [${prefix}`,\n      _type,\n      ignoreDebugReset,\n      // originalStyle || LOGGER_STYLES.reset\n      originalStyle\n      // LOGGER_STYLES.reset\n    );\n  };\n\n  return log;\n};\n","export default function pause(ms: number) {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport pause from '../../helpers/schedulers/pause';\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nexport const CACHE_ASSETS_NAME = 'cachedAssets';\n\nfunction isCorrectResponse(response: Response) {\n  return response.ok && response.status === 200;\n}\n\nfunction timeoutRace<T extends Promise<any>>(promise: T) {\n  return Promise.race([\n    promise,\n    pause(10000).then(() => Promise.reject())\n  ]);\n}\n\nexport async function requestCache(event: FetchEvent) {\n  try {\n    // const cache = await ctx.caches.open(CACHE_ASSETS_NAME);\n    const cache = await timeoutRace(ctx.caches.open(CACHE_ASSETS_NAME));\n    const file = await timeoutRace(cache.match(event.request, {ignoreVary: true}));\n\n    if(file && isCorrectResponse(file)) {\n      return file;\n    }\n\n    const headers: HeadersInit = {'Vary': '*'};\n    let response = await fetch(event.request, {headers});\n    if(isCorrectResponse(response)) {\n      cache.put(event.request, response.clone());\n    } else if(response.status === 304) { // possible fix for 304 in Safari\n      const url = event.request.url.replace(/\\?.+$/, '') + '?' + (Math.random() * 100000 | 0);\n      response = await fetch(url, {headers});\n      if(isCorrectResponse(response)) {\n        cache.put(event.request, response.clone());\n      }\n    }\n\n    return response;\n  } catch(err) {\n    return fetch(event.request);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// import { IS_WEB_WORKER } from \"../context\";\n\n// const id = IS_WEB_WORKER ? Math.random() * 0x1000 | 0 : 0;\nexport default function readBlobAs(blob: Blob, method: 'readAsText'): Promise<string>;\nexport default function readBlobAs(blob: Blob, method: 'readAsDataURL'): Promise<string>;\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer'): Promise<ArrayBuffer>;\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer' | 'readAsText' | 'readAsDataURL'): Promise<any> {\n  // const perf = performance.now();\n  return new Promise<any>((resolve) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', (e) => {\n      // console.log(`readBlobAs [${id}] ${method} time ${performance.now() - perf}`);\n      resolve(e.target.result);\n    });\n    reader[method](blob);\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAs from './readBlobAs';\n\nexport default function readBlobAsArrayBuffer(blob: Blob) {\n  return readBlobAs(blob, 'readAsArrayBuffer');\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAsArrayBuffer from './readBlobAsArrayBuffer';\n\nexport default function readBlobAsUint8Array(blob: Blob) {\n  return readBlobAsArrayBuffer(blob).then((buffer) => new Uint8Array(buffer));\n}\n","export default function noop() {}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport noop from './noop';\n\nexport interface CancellablePromise<T> extends Promise<T> {\n  resolve?: (value: T) => void,\n  reject?: (...args: any[]) => void,\n  cancel?: (reason?: any) => void,\n\n  notify?: (...args: any[]) => void,\n  notifyAll?: (...args: any[]) => void,\n  lastNotify?: any,\n  listeners?: Array<(...args: any[]) => void>,\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\n\n  isFulfilled?: boolean,\n  isRejected?: boolean,\n\n  onFinish?: () => void,\n  _resolve?: (value: T) => void,\n  _reject?: (...args: any[]) => void\n}\n\nconst deferredHelper = {\n  isFulfilled: false,\n  isRejected: false,\n\n  notify: () => {},\n  notifyAll: function(...args: any[]) {\n    this.lastNotify = args;\n    this.listeners?.forEach((callback: any) => callback(...args));\n  },\n\n  addNotifyListener: function(callback: (...args: any[]) => void) {\n    if(this.lastNotify) {\n      callback(...this.lastNotify);\n    }\n\n    (this.listeners ??= []).push(callback);\n  },\n\n  resolve: function(value) {\n    if(this.isFulfilled || this.isRejected) return;\n\n    this.isFulfilled = true;\n    this._resolve(value);\n    this.onFinish();\n  },\n\n  reject: function(...args) {\n    if(this.isRejected || this.isFulfilled) return;\n\n    this.isRejected = true;\n    this._reject(...args);\n    this.onFinish();\n  },\n\n  onFinish: function() {\n    this.notify = this.notifyAll = this.lastNotify = null;\n    if(this.listeners) this.listeners.length = 0;\n\n    if(this.cancel) {\n      this.cancel = noop;\n    }\n  }\n} as CancellablePromise<any>;\n\nexport default function deferredPromise<T>() {\n  let resolve: (value: T) => void, reject: (...args: any[]) => void;\n  const deferred: CancellablePromise<T> = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve, reject = _reject;\n  });\n\n  Object.assign(deferred, deferredHelper);\n  deferred._resolve = resolve;\n  deferred._reject = reject;\n\n  return deferred;\n}\n\n(self as any).deferredPromise = deferredPromise;\n","export default function bytesFromHex(hexString: string) {\n  const len = hexString.length;\n  const bytes = new Uint8Array(Math.ceil(len / 2));\n  let start = 0;\n\n  if(len % 2) { // read 0x581 as 0x0581\n    bytes[start++] = parseInt(hexString.charAt(0), 16);\n  }\n\n  for(let i = start; i < len; i += 2) {\n    bytes[start++] = parseInt(hexString.substr(i, 2), 16);\n  }\n\n  return bytes;\n}\n","export default function bytesCmp(bytes1: number[] | Uint8Array, bytes2: number[] | Uint8Array) {\n  const len = bytes1.length;\n  if(len !== bytes2.length) {\n    return false;\n  }\n\n  for(let i = 0; i < len; ++i) {\n    if(bytes1[i] !== bytes2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import bytesFromHex from './bytes/bytesFromHex';\nimport bytesCmp from './bytes/bytesCmp';\n\nfunction readLengthField(buf: Uint8Array, offset: number) {\n  let length = 0;\n  let size = 0;\n\n  for(let i = 0; i < 4; i++) {\n    const byte = buf[offset + i];\n    length = (length << 7) + (byte & 0x7f);\n    size++;\n    if((byte & 0x80) === 0) {\n      break;\n    }\n  }\n\n  return [size, length];\n}\n\nfunction parseDecoderSpecificInfo(buf: Uint8Array) {\n  if(buf[0] !== 0x05) {\n    throw new Error('Invalid DecoderSpecificInfo tag');\n  }\n\n  const [lenSz, len] = readLengthField(buf, 1);\n  const offset = 1 + lenSz;\n\n  return buf.subarray(offset, offset + len);\n}\n\nfunction parseDecoderConfigDescriptor(buf: Uint8Array) {\n  if(buf[0] !== 0x04) {\n    throw new Error('Invalid DecoderConfigDescriptor tag');\n  }\n\n  const [lenSz, len] = readLengthField(buf, 1);\n  let offset = 1 + lenSz;\n\n  offset += 1 + // oti\n        1 + // flags\n        3 + // bufferSizeDB\n        4 + // maxBitRate\n        4;  // avgBitRate\n\n  const decoderSpecificInfo = parseDecoderSpecificInfo(buf.subarray(offset));\n\n  return decoderSpecificInfo;\n}\n\nfunction parseES_Descriptor(buf: Uint8Array) {\n  if(buf[0] !== 0x03) {\n    throw new Error('Invalid ES_Descriptor tag');\n  }\n\n  const dv = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n  const [lenSz, len] = readLengthField(buf, 1);\n  let offset = 1 + lenSz;\n  offset += 2; // ES_ID\n  const flags = dv.getUint8(offset);\n  offset += 1;\n\n  const streamDependenceFlag = flags & 0x80;\n  const URL_Flag = flags & 0x40;\n\n  if(streamDependenceFlag) {\n    offset += 2;\n  }\n  if(URL_Flag) {\n    const URLlength = readLengthField(buf, offset);\n    offset += 1 + URLlength[0] + URLlength[1];\n  }\n\n  const decoderConfigDescriptor = parseDecoderConfigDescriptor(buf.subarray(offset));\n\n  return {decoderConfigDescriptor};\n}\n\n// function isoMakePath(box: any) {\n//   const path = []\n//   let cur = box\n//   while(cur._parent) {\n//     path.unshift(cur.type)\n//     cur = cur._parent\n//   }\n//   return path.join('.')\n// }\n\nconst BROKEN_DSCI = [0x13, 0x88];\n// a proper working esds, containing:\n// - profile = AAC_LC, sample rate = 22050, channels = MONO\n// - sync extension with profile = AAC_SBR, sample rate = 44100\nconst FIXED_ESDS = bytesFromHex('0327000100041940150000000001f4000000bb750507138856e5a5');\nconst ESDS = new TextEncoder().encode('esds');\nconst MP4A = new TextEncoder().encode('mp4a');\n\nfunction findUint8ArrayBack(buf: Uint8Array, needle: Uint8Array, start = buf.length) {\n  for(let i = start - needle.length; i >= 0; i--) {\n    let found = true;\n    for(let j = 0; j < needle.length; j++) {\n      if(buf[i + j] !== needle[j]) {\n        found = false;\n        break;\n      }\n    }\n    if(found) return i;\n  }\n\n  return -1;\n}\n\nfunction fixMp4ForChromium(u8: Uint8Array) {\n  const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);\n\n  // starting from end is more efficient because mdat is usually at the start\n  let pos = u8.length;\n  let found = null;\n  while(true) {\n    const esdsOffset = findUint8ArrayBack(u8, ESDS, pos);\n    if(esdsOffset === -1) break;\n    pos = esdsOffset;\n\n    // validate size\n    const esdsSize = dv.getUint32(esdsOffset - 4); // mp4 box\n    if(esdsSize < 0 || esdsOffset + esdsSize > u8.length) {\n      // invalid esds\n      continue;\n    }\n\n    // esds can only be inside mp4a\n    const mp4aOffset = findUint8ArrayBack(u8, MP4A, esdsOffset);\n    if(mp4aOffset === -1 || esdsOffset - mp4aOffset > 100) continue;\n\n    found = {offset: esdsOffset + 8, size: esdsSize - 12};\n  }\n\n  if(!found) throw new Error('No ESDS found');\n\n  const esds = u8.subarray(found.offset, found.offset + found.size);\n\n  const parsed = parseES_Descriptor(esds);\n  if(!parsed) throw new Error('Invalid ESDS');\n  if(!bytesCmp(parsed.decoderConfigDescriptor, BROKEN_DSCI)) {\n    throw new Error('Not a broken DSCI');\n  }\n\n  if(found.size < FIXED_ESDS.length) {\n    throw new Error(`ESDS Size not enough (expected at least ${FIXED_ESDS.length}, got ${found.size})`);\n  }\n\n  u8.set(FIXED_ESDS, found.offset);\n}\n\nexport default function tryPatchMp4(u8: Uint8Array) {\n  // since we are patching chunks and not the entire file, only the chunk\n  // containing the ESDS will succeed, so we can safely ignore errors\n  //\n  // there's an edge case where the ESDS is split between two chunks, but\n  // that's quite unlikely to happen, so we ignore it for now\n\n  try {\n    fixMp4ForChromium(u8);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n","// * Jolly Cobra's schedulers\n\nimport ctx from '../../environment/ctx';\nimport {AnyFunction, Awaited} from '../../types';\nimport noop from '../noop';\n\nexport type DebounceReturnType<F extends AnyFunction> = {\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n  clearTimeout(): void;\n  isDebounced(): boolean;\n};\n\nexport default function debounce<F extends AnyFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n  shouldRunLast = true\n): DebounceReturnType<F> {\n  let waitingTimeout: number;\n  let waitingPromise: Promise<Awaited<ReturnType<F>>>, resolve: (result: any) => void, reject: () => void;\n  let hadNewCall = false;\n\n  const invoke = (args: Parameters<F>) => {\n    const _resolve = resolve, _reject = reject;\n    try {\n      const result = fn.apply(null, args);\n      _resolve(result);\n    } catch(err) {\n      console.error('debounce error', err);\n      // @ts-ignore\n      _reject(err);\n    }\n  };\n\n  const debounce = (...args: Parameters<F>) => {\n    if(!waitingPromise) waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\n\n    if(waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      hadNewCall = true;\n      reject();\n      waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\n    } else if(shouldRunFirst) {\n      invoke(args);\n      hadNewCall = false;\n    }\n\n    const _waitingTimeout = ctx.setTimeout(() => {\n      // will run if should run last or first but with new call\n      if(shouldRunLast && (!shouldRunFirst || hadNewCall)) {\n        invoke(args);\n      }\n\n      // if debounce was called during invoking\n      if(waitingTimeout === _waitingTimeout) {\n        waitingTimeout = waitingPromise = resolve = reject = undefined;\n        hadNewCall = false;\n      }\n    }, ms);\n\n    waitingTimeout = _waitingTimeout;\n    waitingPromise.catch(noop);\n    return waitingPromise;\n  };\n\n  debounce.clearTimeout = () => {\n    if(waitingTimeout) {\n      ctx.clearTimeout(waitingTimeout);\n      reject();\n      waitingTimeout = waitingPromise = resolve = reject = undefined;\n      hadNewCall = false;\n    }\n  };\n\n  debounce.isDebounced = () => !!waitingTimeout;\n\n  return debounce;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\n// https://www.iana.org/assignments/media-types/media-types.xhtml\nexport default function blobSafeMimeType(mimeType: string) {\n  if([\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'image/svg+xml',\n    'image/webp',\n    'image/bmp',\n    'image/avif',\n    'image/jxl',\n    'video/mp4',\n    'video/webm',\n    'video/quicktime',\n    'audio/ogg',\n    'audio/mpeg',\n    'audio/mp4',\n    'audio/wav', // though it is not in list\n    'application/json',\n    'application/pdf'\n  ].indexOf(mimeType) === -1) {\n    return 'application/octet-stream';\n  }\n\n  return mimeType;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport blobSafeMimeType from './blobSafeMimeType';\n\nexport default function blobConstruct<T extends Uint8Array | string>(blobParts: Array<T> | T, mimeType: string = ''): Blob {\n  if(!Array.isArray(blobParts)) {\n    blobParts = [blobParts];\n  }\n\n  const safeMimeType = blobSafeMimeType(mimeType);\n  const blob = new Blob(blobParts, {type: safeMimeType});\n  return blob;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport blobConstruct from '../../helpers/blob/blobConstruct';\nimport StreamWriter from './streamWriter';\n\nexport default class MemoryWriter implements StreamWriter {\n  private bytes: Uint8Array;\n\n  constructor(\n    private mimeType: string,\n    private size: number,\n    private saveFileCallback?: (blob: Blob) => Promise<Blob>\n  ) {\n    this.bytes = new Uint8Array(size);\n  }\n\n  public async write(part: Uint8Array, offset: number) {\n    // sometimes file size can be bigger than the prov\n    const endOffset = offset + part.byteLength;\n    if(endOffset > this.bytes.byteLength) {\n      const newBytes = new Uint8Array(endOffset);\n      newBytes.set(this.bytes, 0);\n      this.bytes = newBytes;\n    }\n\n    this.bytes.set(part, offset);\n  };\n\n  public truncate() {\n    this.bytes = new Uint8Array();\n  }\n\n  public trim(size: number) {\n    this.bytes = this.bytes.slice(0, size);\n  }\n\n  public finalize(saveToStorage = true) {\n    const blob = blobConstruct(this.bytes, this.mimeType);\n\n    if(saveToStorage && this.saveFileCallback) {\n      this.saveFileCallback(blob);\n    }\n\n    return blob;\n  }\n\n  public getParts() {\n    return this.bytes;\n  }\n\n  public replaceParts(parts: Uint8Array) {\n    this.bytes = parts;\n  }\n}\n","const CACHED_ERRORS: {[key in Error['type']]?: ApiError} = {};\nexport default function makeError(type: Error['type']) {\n  return CACHED_ERRORS[type] ??= {\n    type\n  };\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from '../../config/modes';\nimport blobConstruct from '../../helpers/blob/blobConstruct';\nimport MemoryWriter from './memoryWriter';\nimport FileManager from './memoryWriter';\nimport FileStorage from './fileStorage';\nimport makeError from '../../helpers/makeError';\nimport deferredPromise from '../../helpers/cancellablePromise';\n\nexport type CacheStorageDbName = 'cachedFiles' | 'cachedStreamChunks' | 'cachedAssets';\n\nexport default class CacheStorageController implements FileStorage {\n  private static STORAGES: CacheStorageController[] = [];\n  private openDbPromise: Promise<Cache>;\n\n  private useStorage = true;\n\n  // private log: ReturnType<typeof logger> = logger('CS');\n\n  constructor(private dbName: CacheStorageDbName) {\n    if(Modes.test) {\n      this.dbName += '_test';\n    }\n\n    if(CacheStorageController.STORAGES.length) {\n      this.useStorage = CacheStorageController.STORAGES[0].useStorage;\n    }\n\n    this.openDatabase();\n    CacheStorageController.STORAGES.push(this);\n  }\n\n  private openDatabase(): Promise<Cache> {\n    return this.openDbPromise ?? (this.openDbPromise = caches.open(this.dbName));\n  }\n\n  public delete(entryName: string) {\n    return this.timeoutOperation((cache) => cache.delete('/' + entryName));\n  }\n\n  public deleteAll() {\n    return caches.delete(this.dbName);\n  }\n\n  public get(entryName: string) {\n    return this.timeoutOperation((cache) => cache.match('/' + entryName));\n  }\n\n  public save(entryName: string, response: Response) {\n    // return new Promise((resolve) => {}); // DEBUG\n    return this.timeoutOperation((cache) => cache.put('/' + entryName, response));\n  }\n\n  public getFile(fileName: string, method: 'blob' | 'json' | 'text' = 'blob'): Promise<any> {\n    // if(method === 'blob') {\n    //   return Promise.reject(makeError('NO_ENTRY_FOUND'));\n    // }\n\n    // const str = `get fileName: ${fileName}`;\n    // console.time(str);\n    return this.get(fileName).then((response) => {\n      if(!response) {\n        // console.warn('getFile:', response, fileName);\n        throw makeError('NO_ENTRY_FOUND');\n      }\n\n      const promise = response[method]();\n      // promise.then(() => {\n      //   console.timeEnd(str);\n      // });\n      return promise;\n    });\n  }\n\n  public saveFile(fileName: string, blob: Blob | Uint8Array) {\n    // return Promise.resolve(blobConstruct([blob]));\n    if(!(blob instanceof Blob)) {\n      blob = blobConstruct(blob);\n    }\n\n    const response = new Response(blob, {\n      headers: {\n        'Content-Length': '' + blob.size\n      }\n    });\n\n    return this.save(fileName, response).then(() => blob as Blob);\n  }\n\n  public timeoutOperation<T>(callback: (cache: Cache) => Promise<T>) {\n    if(!this.useStorage) {\n      return Promise.reject(makeError('STORAGE_OFFLINE'));\n    }\n\n    return new Promise<T>(async(resolve, reject) => {\n      let rejected = false;\n      const timeout = setTimeout(() => {\n        reject();\n        // console.warn('CACHESTORAGE TIMEOUT');\n        rejected = true;\n      }, 15e3);\n\n      try {\n        const cache = await this.openDatabase();\n        if(!cache) {\n          this.useStorage = false;\n          this.openDbPromise = undefined;\n          throw 'no cache?';\n        }\n\n        const res = await callback(cache);\n\n        if(rejected) return;\n        resolve(res);\n      } catch(err) {\n        reject(err);\n      }\n\n      clearTimeout(timeout);\n    });\n  }\n\n  public prepareWriting(fileName: string, fileSize: number, mimeType: string) {\n    return {\n      deferred: deferredPromise<Blob>(),\n      getWriter: () => {\n        const writer = new MemoryWriter(mimeType, fileSize, (blob) => {\n          return this.saveFile(fileName, blob).catch(() => blob);\n        });\n\n        return writer;\n      }\n    };\n  }\n\n  public static toggleStorage(enabled: boolean, clearWrite: boolean) {\n    return Promise.all(this.STORAGES.map((storage) => {\n      storage.useStorage = enabled;\n\n      if(!clearWrite) {\n        return;\n      }\n\n      if(!enabled) {\n        return storage.deleteAll();\n      }\n    }));\n  }\n}\n","export default function timeout(delay: number): Promise<Response> {\n  return new Promise(((resolve) => {\n    setTimeout(() => {\n      resolve(new Response('', {\n        status: 408,\n        statusText: 'Request timed out.'\n      }));\n    }, delay);\n  }));\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport readBlobAsUint8Array from '../../helpers/blob/readBlobAsUint8Array';\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\nimport tryPatchMp4 from '../../helpers/fixChromiumMp4';\nimport debounce from '../../helpers/schedulers/debounce';\nimport pause from '../../helpers/schedulers/pause';\nimport {InputFileLocation} from '../../layer';\nimport CacheStorageController from '../files/cacheStorage';\nimport {DownloadOptions, MyUploadFile} from '../mtproto/apiFileManager';\nimport {getMtprotoMessagePort, log, serviceMessagePort} from './index.service';\nimport {ServiceRequestFilePartTaskPayload} from './serviceMessagePort';\nimport timeout from './timeout';\n\nconst deferredPromises: Map<MessagePort, {[taskId: string]: CancellablePromise<MyUploadFile>}> = new Map();\nconst cacheStorage = new CacheStorageController('cachedStreamChunks');\nconst CHUNK_TTL = 86400;\nconst CHUNK_CACHED_TIME_HEADER = 'Time-Cached';\nconst USE_CACHE = true;\nconst TEST_SLOW = false;\n\nconst clearOldChunks = () => {\n  return cacheStorage.timeoutOperation((cache) => {\n    return cache.keys().then((requests) => {\n      const filtered: Map<StreamId, Request> = new Map();\n      const timestamp = Date.now() / 1000 | 0;\n      for(const request of requests) {\n        const match = request.url.match(/\\/(\\d+?)\\?/);\n        if(match && !filtered.has(match[1])) {\n          filtered.set(match[1], request);\n        }\n      }\n\n      const promises: Promise<any>[] = [];\n      for(const [id, request] of filtered) {\n        const promise = cache.match(request).then((response) => {\n          if((+response.headers.get(CHUNK_CACHED_TIME_HEADER) + CHUNK_TTL) <= timestamp) {\n            log('will delete stream chunk:', id);\n            return cache.delete(request, {ignoreSearch: true, ignoreVary: true});\n          }\n        });\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    });\n  });\n};\n\nsetInterval(clearOldChunks, 1800e3);\nsetInterval(() => {\n  const mtprotoMessagePort = getMtprotoMessagePort();\n  for(const [messagePort, promises] of deferredPromises) {\n    if(messagePort === mtprotoMessagePort) {\n      continue;\n    }\n\n    for(const taskId in promises) {\n      const promise = promises[taskId];\n      promise.reject();\n    }\n\n    deferredPromises.delete(messagePort);\n  }\n}, 120e3);\n\ntype StreamRange = [number, number];\ntype StreamId = DocId;\nconst streams: Map<StreamId, Stream> = new Map();\nclass Stream {\n  private destroyDebounced: () => void;\n  private id: StreamId;\n  private limitPart: number;\n  private loadedOffsets: Set<number> = new Set();\n  private shouldPatchMp4: boolean | number;\n\n  constructor(private info: DownloadOptions) {\n    this.id = Stream.getId(info);\n    streams.set(this.id, this);\n\n    // ! если грузить очень большое видео чанками по 512Кб в мобильном Safari, то стрим не запустится\n    this.limitPart = info.size > (75 * 1024 * 1024) ? STREAM_CHUNK_UPPER_LIMIT : STREAM_CHUNK_MIDDLE_LIMIT;\n    this.destroyDebounced = debounce(this.destroy, 150000, false, true);\n  }\n\n  private destroy = () => {\n    streams.delete(this.id);\n  };\n\n  private async requestFilePartFromWorker(alignedOffset: number, limit: number, fromPreload = false) {\n    const payload: ServiceRequestFilePartTaskPayload = {\n      docId: this.id,\n      dcId: this.info.dcId,\n      offset: alignedOffset,\n      limit\n    };\n\n    const taskId = JSON.stringify(payload);\n\n    const mtprotoMessagePort = getMtprotoMessagePort();\n    let promises = deferredPromises.get(mtprotoMessagePort);\n    if(!promises) {\n      deferredPromises.set(mtprotoMessagePort, promises = {});\n    }\n\n    let deferred = promises[taskId];\n    if(deferred) {\n      return deferred.then((uploadFile) => uploadFile.bytes);\n    }\n\n    this.loadedOffsets.add(alignedOffset);\n\n    deferred = promises[taskId] = deferredPromise();\n\n    serviceMessagePort.invoke('requestFilePart', payload, undefined, mtprotoMessagePort)\n    .then(deferred.resolve.bind(deferred), deferred.reject.bind(deferred)).finally(() => {\n      if(promises[taskId] === deferred) {\n        delete promises[taskId];\n\n        if(!Object.keys(promises).length) {\n          deferredPromises.delete(mtprotoMessagePort);\n        }\n      }\n    });\n\n    const bytesPromise = deferred.then((uploadFile) => uploadFile.bytes);\n\n    if(USE_CACHE) {\n      this.saveChunkToCache(bytesPromise, alignedOffset, limit);\n      !fromPreload && this.preloadChunks(alignedOffset, alignedOffset + (this.limitPart * 15));\n    }\n\n    return bytesPromise;\n  }\n\n  private requestFilePartFromCache(alignedOffset: number, limit: number, fromPreload?: boolean) {\n    if(!USE_CACHE) {\n      return Promise.resolve();\n    }\n\n    const key = this.getChunkKey(alignedOffset, limit);\n    return cacheStorage.getFile(key).then((blob: Blob) => {\n      return fromPreload ? new Uint8Array() : readBlobAsUint8Array(blob);\n    }, (error: ApiError) => {\n      if(error.type === 'NO_ENTRY_FOUND') {\n        return;\n      }\n    });\n  }\n\n  private requestFilePart(alignedOffset: number, limit: number, fromPreload?: boolean) {\n    const promise = this.requestFilePartFromCache(alignedOffset, limit, fromPreload).then((bytes) => {\n      return bytes || this.requestFilePartFromWorker(alignedOffset, limit, fromPreload);\n    });\n\n    if(TEST_SLOW) {\n      return promise.then((bytes) => {\n        log.warn('delaying chunk', alignedOffset, limit);\n        return pause(3000).then(() => {\n          log.warn('releasing chunk', alignedOffset, limit);\n          return bytes;\n        });\n      });\n    }\n\n    return promise;\n  }\n\n  private saveChunkToCache(deferred: Promise<Uint8Array>, alignedOffset: number, limit: number) {\n    return deferred.then((bytes) => {\n      const key = this.getChunkKey(alignedOffset, limit);\n      const response = new Response(bytes, {\n        headers: {\n          'Content-Length': '' + bytes.length,\n          'Content-Type': 'application/octet-stream',\n          [CHUNK_CACHED_TIME_HEADER]: '' + (Date.now() / 1000 | 0)\n        }\n      });\n\n      return cacheStorage.save(key, response);\n    });\n  }\n\n  private preloadChunk(offset: number) {\n    if(this.loadedOffsets.has(offset)) {\n      return;\n    }\n\n    this.loadedOffsets.add(offset);\n    this.requestFilePart(offset, this.limitPart, true);\n  }\n\n  private preloadChunks(offset: number, end: number) {\n    if(end > this.info.size) {\n      end = this.info.size;\n    }\n\n    if(!offset) { // load last chunk for bounds\n      this.preloadChunk(alignOffset(offset, this.limitPart));\n    } else { // don't preload next chunks before the start\n      for(; offset < end; offset += this.limitPart) {\n        this.preloadChunk(offset);\n      }\n    }\n  }\n\n  public requestRange(range: StreamRange) {\n    this.destroyDebounced();\n\n    const possibleResponse = responseForSafariFirstRange(range, this.info.mimeType, this.info.size);\n    if(possibleResponse) {\n      return possibleResponse;\n    }\n\n    let [offset, end] = range;\n\n    /* if(info.size > limitPart && isSafari && offset === limitPart) {\n      //end = info.size - 1;\n      //offset = info.size - 1 - limitPart;\n      offset = info.size - (info.size % limitPart);\n    } */\n\n    const limit = end && end < this.limitPart ? alignLimit(end - offset + 1) : this.limitPart;\n    const alignedOffset = alignOffset(offset, limit);\n\n    if(!end) {\n      end = Math.min(offset + limit, this.info.size - 1);\n    }\n\n    return this.requestFilePart(alignedOffset, limit).then((ab) => {\n      // log.debug('[stream] requestFilePart result:', result);\n\n      // if(isSafari) {\n      if(offset !== alignedOffset || end !== (alignedOffset + limit)) {\n        ab = ab.slice(offset - alignedOffset, end - alignedOffset + 1);\n      }\n\n      if(this.shouldPatchMp4 === true || this.shouldPatchMp4 === alignedOffset) {\n        if(tryPatchMp4(ab)) {\n          this.shouldPatchMp4 = alignedOffset;\n        }\n      }\n      // if(this.shouldPatchMp4) {\n      //   tryPatchMp4(ab);\n      // }\n\n      const headers: Record<string, string> = {\n        'Accept-Ranges': 'bytes',\n        'Content-Range': `bytes ${offset}-${offset + ab.byteLength - 1}/${this.info.size || '*'}`,\n        'Content-Length': `${ab.byteLength}`\n      };\n\n      if(this.info.mimeType) {\n        headers['Content-Type'] = this.info.mimeType;\n      }\n\n      // simulate slow connection\n      // setTimeout(() => {\n      return new Response(ab, {\n        status: 206,\n        statusText: 'Partial Content',\n        headers\n      });\n      // }, 2.5e3);\n    });\n  }\n\n  private getChunkKey(alignedOffset: number, limit: number) {\n    return this.id + '?offset=' + alignedOffset + '&limit=' + limit;\n  }\n\n  public patchChromiumMp4() {\n    this.shouldPatchMp4 = true;\n  }\n\n  public static get(info: DownloadOptions) {\n    return streams.get(this.getId(info)) ?? new Stream(info);\n  }\n\n  private static getId(info: DownloadOptions) {\n    return (info.location as InputFileLocation.inputDocumentFileLocation).id;\n  }\n}\n\nexport default function onStreamFetch(event: FetchEvent, params: string, search: string) {\n  const range = parseRange(event.request.headers.get('Range'));\n  const info: DownloadOptions = JSON.parse(decodeURIComponent(params));\n  const stream = Stream.get(info);\n\n  if(search === '_crbug1250841') {\n    stream.patchChromiumMp4();\n  }\n\n  // log.debug('[stream]', url, offset, end);\n\n  event.respondWith(Promise.race([\n    timeout(45 * 1000),\n    stream.requestRange(range)\n  ]));\n}\n\nfunction responseForSafariFirstRange(range: StreamRange, mimeType: string, size: number): Response {\n  if(range[0] === 0 && range[1] === 1) {\n    return new Response(new Uint8Array(2).buffer, {\n      status: 206,\n      statusText: 'Partial Content',\n      headers: {\n        'Accept-Ranges': 'bytes',\n        'Content-Range': `bytes 0-1/${size || '*'}`,\n        'Content-Length': '2',\n        'Content-Type': mimeType || 'video/mp4'\n      }\n    });\n  }\n\n  return null;\n}\n\n/* const STREAM_CHUNK_UPPER_LIMIT = 256 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 256 * 4; */\n/* const STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 1024 * 4; */\nconst STREAM_CHUNK_MIDDLE_LIMIT = 512 * 1024;\nconst STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 512 * 4;\n\nfunction parseRange(header: string): StreamRange {\n  if(!header) return [0, 0];\n  const [, chunks] = header.split('=');\n  const ranges = chunks.split(', ');\n  const [offset, end] = ranges[0].split('-');\n\n  return [+offset, +end || 0];\n}\n\nfunction alignOffset(offset: number, base = SMALLEST_CHUNK_LIMIT) {\n  return offset - (offset % base);\n}\n\nfunction alignLimit(limit: number) {\n  return 2 ** Math.ceil(Math.log(limit) / Math.log(2));\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {Database} from '.';\nimport type {IDBIndex} from '../../lib/files/idb';\n\nconst DATABASE_STATE: Database<'session' | 'stickerSets' | 'users' | 'chats' | 'messages' | 'dialogs'> = {\n  name: 'tweb',\n  version: 7,\n  stores: [{\n    name: 'session'\n  }, {\n    name: 'stickerSets'\n  }, {\n    name: 'users'\n  }, {\n    name: 'chats'\n  }, {\n    name: 'dialogs'\n    // indexes: [\n    //   ...(new Array(20 + 2).fill(0)).map((_, idx) => {\n    //     const name = `index_${idx}`;\n    //     const index: IDBIndex = {\n    //       indexName: name,\n    //       keyPath: name,\n    //       objectParameters: {}\n    //     };\n\n    //     return index\n    //   })\n    // ]\n  }, {\n    name: 'messages'\n  }]\n};\n\nexport default DATABASE_STATE;\n","export const NOTIFICATION_ICON_PATH = 'assets/img/logo_filled_rounded.png';\nexport const NOTIFICATION_BADGE_PATH = 'assets/img/logo_plain.svg'; // masked\n","/**\n * ignores `undefined` properties\n */\nexport default function deepEqual<T>(x: T, y: T, ignoreKeys?: (keyof T)[]): boolean {\n  const ignoreSet = ignoreKeys && new Set(ignoreKeys);\n  const okok = (obj: any) => Object.keys(obj).filter((key) => obj[key] !== undefined);\n  const ok = ignoreKeys ? (obj: any) => okok(obj).filter((key) => !ignoreSet.has(key as any)) : okok,\n    tx = typeof x,\n    ty = typeof y;\n  return x && y && tx === 'object' && tx === ty ? (\n    ok(x).length === ok(y).length &&\n      ok(x).every((key) => deepEqual((x as any)[key], (y as any)[key], ignoreKeys))\n  ) : (x === y);\n}\n","export default function safeAssign<T>(object: T, fromObject: any) {\n  if(fromObject) {\n    for(const i in fromObject) {\n      if(fromObject[i] !== undefined) {\n        // @ts-ignore\n        object[i] = fromObject[i];\n      }\n    }\n  }\n\n  return object;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {Database} from '../../config/databases';\nimport Modes from '../../config/modes';\nimport makeError from '../../helpers/makeError';\nimport safeAssign from '../../helpers/object/safeAssign';\nimport {logger} from '../logger';\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex\n */\nexport type IDBIndex = {\n  indexName: string,\n  keyPath: string,\n  objectParameters: IDBIndexParameters\n};\n\nexport type IDBStore = {\n  name: string,\n  indexes?: IDBIndex[]\n};\n\nexport type IDBOptions = {\n  name?: string,\n  storeName: string,\n  stores?: IDBStore[],\n  version?: number\n};\n\nconst DEBUG = false;\n\nexport class IDB {\n  private static INSTANCES: IDB[] = [];\n  private openDbPromise: Promise<IDBDatabase>;\n  private db: IDBDatabase;\n  private storageIsAvailable: boolean;\n  private log: ReturnType<typeof logger>;\n  private name: string;\n  private version: number;\n  private stores: IDBStore[];\n\n  constructor(db: Database<any>) {\n    safeAssign(this, db);\n\n    if(Modes.test) {\n      this.name += '_test';\n    }\n\n    this.storageIsAvailable = true;\n    this.log = logger(['IDB', db.name].join('-'));\n    this.log('constructor');\n\n    this.openDatabase(true);\n\n    IDB.INSTANCES.push(this);\n  }\n\n  public isAvailable() {\n    return this.storageIsAvailable;\n  }\n\n  public openDatabase(createNew = false): Promise<IDBDatabase> {\n    if(this.openDbPromise && !createNew) {\n      return this.openDbPromise;\n    }\n\n    const createIndexes = (os: IDBObjectStore, store: IDBStore) => {\n      const indexNames = Array.from(os.indexNames);\n      for(const indexName of indexNames) {\n        os.deleteIndex(indexName);\n      }\n\n      if(!store.indexes?.length) {\n        return;\n      }\n\n      for(const index of store.indexes) {\n        if(os.indexNames.contains(index.indexName)) {\n          continue;\n        }\n\n        os.createIndex(index.indexName, index.keyPath, index.objectParameters);\n      }\n    };\n\n    const createObjectStore = (db: IDBDatabase, store: IDBStore) => {\n      const os = db.createObjectStore(store.name);\n      createIndexes(os, store);\n    };\n\n    try {\n      var request = indexedDB.open(this.name, this.version);\n\n      if(!request) {\n        return Promise.reject();\n      }\n    } catch(error) {\n      this.log.error('error opening db', (error as Error).message);\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    let finished = false;\n    setTimeout(() => {\n      if(!finished) {\n        request.onerror(makeError('IDB_CREATE_TIMEOUT') as Event);\n      }\n    }, 3000);\n\n    return this.openDbPromise = new Promise<IDBDatabase>((resolve, reject) => {\n      request.onsuccess = (event) => {\n        finished = true;\n        const db = request.result;\n        let calledNew = false;\n\n        this.log('Opened');\n\n        db.onerror = (error) => {\n          this.storageIsAvailable = false;\n          this.log.error('Error creating/accessing IndexedDB database', error);\n          reject(error);\n        };\n\n        db.onclose = (e) => {\n          this.log.error('closed:', e);\n          !calledNew && this.openDatabase();\n        };\n\n        db.onabort = (e) => {\n          this.log.error('abort:', e);\n          const transaction = e.target as IDBTransaction;\n\n          this.openDatabase(calledNew = true);\n\n          if(transaction.onerror) {\n            transaction.onerror(e);\n          }\n\n          db.close();\n        };\n\n        db.onversionchange = (e) => {\n          this.log.error('onversionchange, lol?');\n        };\n\n        resolve(this.db = db);\n      };\n\n      request.onerror = (event) => {\n        finished = true;\n        this.storageIsAvailable = false;\n        this.log.error('Error creating/accessing IndexedDB database', event);\n        reject(event);\n      };\n\n      request.onupgradeneeded = (event) => {\n        finished = true;\n        this.log.warn('performing idb upgrade from', event.oldVersion, 'to', event.newVersion);\n\n        const target = event.target as IDBOpenDBRequest;\n        const db = target.result;\n        this.stores.forEach((store) => {\n          /* if(db.objectStoreNames.contains(store.name)) {\n            //if(event.oldVersion === 1) {\n              db.deleteObjectStore(store.name);\n            //}\n          } */\n\n          if(!db.objectStoreNames.contains(store.name)) {\n            createObjectStore(db, store);\n          } else {\n            const txn = target.transaction;\n            const os = txn.objectStore(store.name);\n            createIndexes(os, store);\n          }\n        });\n      };\n    });\n  }\n\n  public static create<T extends Database<any>>(db: T) {\n    return this.INSTANCES.find((instance) => instance.name === db.name) ?? new IDB(db);\n  }\n\n  public static closeDatabases(preserve?: IDB) {\n    this.INSTANCES.forEach((storage) => {\n      if(preserve && preserve === storage) {\n        return;\n      }\n\n      const db = storage.db;\n      if(db) {\n        db.onclose = () => {};\n        db.close();\n      }\n    });\n  }\n}\n\nexport default class IDBStorage<T extends Database<any>, StoreName extends string = T['stores'][0]['name']> {\n  private log: ReturnType<typeof logger>;\n  private storeName: T['stores'][0]['name'];\n  private idb: IDB;\n\n  constructor(db: T, storeName: typeof db['stores'][0]['name']) {\n    this.storeName = storeName;\n    this.log = logger(['IDB', db.name, storeName].join('-'));\n    this.idb = IDB.create(db);\n  }\n\n  /**\n   * ! WARNING ! function requires at least one opened connection\n   */\n  /* public static clearObjectStores() {\n    const storage = this.STORAGES[0];\n    this.closeDatabases(storage);\n\n    const names = Array.from(storage.db.objectStoreNames);\n    const promises = names.map((name) => storage.clear(name));\n    return Promise.all(promises);\n  } */\n\n  /* public static deleteDatabase() {\n    this.closeDatabases();\n\n    const storages = this.STORAGES;\n    const dbNames = Array.from(new Set(storages.map((storage) => storage.name)));\n    const promises = dbNames.map((dbName) => {\n      return new Promise<void>((resolve, reject) => {\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\n\n        deleteRequest.onerror = () => {\n          reject();\n        };\n\n        deleteRequest.onsuccess = () => {\n          resolve();\n        };\n      });\n    });\n\n    return Promise.all(promises);\n  } */\n\n  public delete(entryName: string | string[], storeName?: StoreName): Promise<void> {\n    // return Promise.resolve();\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      entryName = [].concat(entryName);\n    }\n\n    return this.getObjectStore('readwrite', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName) => objectStore.delete(entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'delete: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  public clear(storeName?: StoreName): Promise<void> {\n    return this.getObjectStore('readwrite', (objectStore) => objectStore.clear(), DEBUG ? 'clear' : '', storeName);\n  }\n\n  public save(entryName: string | string[], value: any | any[], storeName?: StoreName) {\n    // const handleError = (error: Error) => {\n    //   this.log.error('save: transaction error:', entryName, value, db, error, error && error.name);\n    //   if((!error || error.name === 'InvalidStateError')/*  && false */) {\n    //     setTimeout(() => {\n    //       this.save(entryName, value);\n    //     }, 2e3);\n    //   } else {\n    //     //console.error('IndexedDB saveFile transaction error:', error, error && error.name);\n    //   }\n    // };\n\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      entryName = [].concat(entryName);\n      value = [].concat(value);\n    }\n\n    return this.getObjectStore('readwrite', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName, idx) => objectStore.put(value[idx], entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'save: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  // public saveFile(fileName: string, blob: Blob | Uint8Array) {\n  //   //return Promise.resolve(blobConstruct([blob]));\n  //   if(!(blob instanceof Blob)) {\n  //     blob = blobConstruct(blob);\n  //   }\n\n  //   return this.save(fileName, blob);\n  // }\n\n  /* public saveFileBase64(db: IDBDatabase, fileName: string, blob: Blob | any): Promise<Blob> {\n    if(this.getBlobSize(blob) > 10 * 1024 * 1024) {\n      return Promise.reject();\n    }\n\n    if(!(blob instanceof Blob)) {\n      var safeMimeType = blobSafeMimeType(blob.type || 'image/jpeg');\n      var address = 'data:' + safeMimeType + ';base64,' + bytesToBase64(blob);\n      return this.storagePutB64String(db, fileName, address).then(() => {\n        return blob;\n      });\n    }\n\n    try {\n      var reader = new FileReader();\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    let promise = new Promise<Blob>((resolve, reject) => {\n      reader.onloadend = () => {\n        this.storagePutB64String(db, fileName, reader.result as string).then(() => {\n          resolve(blob);\n        }, reject);\n      }\n\n      reader.onerror = reject;\n    });\n\n\n    try {\n      reader.readAsDataURL(blob);\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    return promise;\n  }\n\n  public storagePutB64String(db: IDBDatabase, fileName: string, b64string: string) {\n    try {\n      var objectStore = db.transaction([this.storeName], 'readwrite')\n        .objectStore(this.storeName);\n      var request = objectStore.put(b64string, fileName);\n    } catch(error) {\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = function(event) {\n        resolve();\n      };\n\n      request.onerror = reject;\n    });\n  }\n\n  public getBlobSize(blob: any) {\n    return blob.size || blob.byteLength || blob.length;\n  } */\n\n  public get<T>(entryName: string[], storeName?: StoreName): Promise<T[]>;\n  public get<T>(entryName: string, storeName?: StoreName): Promise<T>;\n  public get<T>(entryName: string | string[], storeName?: StoreName): Promise<T> | Promise<T[]> {\n    // return Promise.reject();\n\n    const isArray = Array.isArray(entryName);\n    if(!isArray) {\n      if(!entryName) {\n        return undefined;\n      }\n\n      entryName = [].concat(entryName);\n    } else if(!entryName.length) {\n      return Promise.resolve([]) as any;\n    }\n\n    return this.getObjectStore<T>('readonly', (objectStore) => {\n      const promises = (entryName as string[]).map((entryName) => objectStore.get(entryName));\n      return isArray ? promises : promises[0];\n    }, DEBUG ? 'get: ' + (entryName as string[]).join(', ') : '', storeName);\n  }\n\n  private getObjectStore<T>(\n    mode: IDBTransactionMode,\n    callback: (objectStore: IDBObjectStore) => IDBRequest | IDBRequest[],\n    log?: string,\n    storeName = this.storeName\n  ) {\n    let perf: number;\n\n    if(log) {\n      perf = performance.now();\n      this.log(log + ': start');\n    }\n\n    return this.idb.openDatabase().then((db) => {\n      return new Promise<T>((resolve, reject) => {\n        /* if(mode === 'readwrite') {\n          return;\n        } */\n\n        // * https://developer.chrome.com/blog/indexeddb-durability-mode-now-defaults-to-relaxed\n        const transaction = db.transaction([storeName], mode, {durability: 'relaxed'});\n\n        const onError = () => {\n          clearTimeout(timeout);\n          reject(transaction.error);\n        };\n\n        // let resolved = false;\n        const onComplete = (/* what: string */) => {\n          clearTimeout(timeout);\n\n          if(log) {\n            this.log(log + ': end', performance.now() - perf/* , what */);\n          }\n\n          // if(resolved) {\n          //   return;\n          // }\n\n          // resolved = true;\n          const results = requests.map((r) => r.result);\n          resolve(isArray ? results : results[0]);\n        };\n\n        transaction.onerror = onError;\n\n        // * have to wait while clearing or setting something\n        const waitForTransactionComplete = mode === 'readwrite';\n        if(waitForTransactionComplete) {\n          transaction.oncomplete = () => onComplete(/* 'transaction' */);\n        }\n\n        const timeout = setTimeout(() => {\n          this.log.error('transaction not finished', transaction, log);\n        }, 10000);\n\n        /* transaction.addEventListener('abort', (e) => {\n          //handleError();\n          this.log.error('IndexedDB: transaction abort!', transaction.error);\n        }); */\n\n        const callbackResult = callback(transaction.objectStore(storeName));\n\n        const isArray = Array.isArray(callbackResult);\n        const requests: IDBRequest[] = isArray ? callbackResult : [].concat(callbackResult) as any;\n\n        if(waitForTransactionComplete) {\n          return;\n        }\n\n        const length = requests.length;\n        let left = length;\n\n        const onRequestFinished = () => {\n          if(transaction.error) {\n            return;\n          }\n\n          if(!--left) {\n            onComplete(/* 'requests' */);\n          }\n        };\n\n        for(let i = 0; i < length; ++i) {\n          const request = requests[i];\n          request.onerror = onError;\n          request.onsuccess = onRequestFinished;\n        }\n      });\n    });\n  }\n\n  public getAll<T>(storeName?: StoreName): Promise<T[]> {\n    return this.getObjectStore<T[]>('readonly', (objectStore) => objectStore.getAll(), DEBUG ? 'getAll' : '', storeName);\n  }\n\n  /* public getAllKeys(): Promise<Array<string>> {\n    console.time('getAllEntries');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.getAllKeys();\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var result = event.target.result;\n          resolve(result);\n          console.timeEnd('getAllEntries');\n        }\n\n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public isFileExists(fileName: string): Promise<boolean> {\n    console.time('isFileExists');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.openCursor(fileName);\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var cursor = event.target.result;\n          resolve(!!cursor);\n          console.timeEnd('isFileExists');\n        }\n\n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public getFileWriter(fileName: string, mimeType: string) {\n    var fakeWriter = FileManager.getFakeFileWriter(mimeType, (blob) => {\n      return this.saveFile(fileName, blob);\n    });\n\n    return Promise.resolve(fakeWriter);\n  } */\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport {Database} from '../../config/databases';\nimport DATABASE_STATE from '../../config/databases/state';\nimport {NOTIFICATION_BADGE_PATH, NOTIFICATION_ICON_PATH} from '../../config/notifications';\nimport {IS_FIREFOX} from '../../environment/userAgent';\nimport deepEqual from '../../helpers/object/deepEqual';\nimport IDBStorage from '../files/idb';\nimport {log, serviceMessagePort} from './index.service';\nimport {ServicePushPingTaskPayload} from './serviceMessagePort';\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nconst defaultBaseUrl = location.protocol + '//' + location.hostname + location.pathname.split('/').slice(0, -1).join('/') + '/';\n\n// as in webPushApiManager.ts\nconst PING_PUSH_TIMEOUT = 10000 + 1500;\nlet lastPingTime = 0;\nlet localNotificationsAvailable = true;\n\nexport type PushNotificationObject = {\n  loc_key: string,\n  loc_args: string[],\n  // user_id: number, // should be number\n  custom: {\n    channel_id?: string, // should be number\n    chat_id?: string, // should be number\n    from_id?: string, // should be number\n    msg_id: string,\n    peerId?: string, // should be number\n    silent?: string // can be '1'\n  },\n  sound?: string,\n  random_id: number,\n  badge?: string, // should be number\n  description: string,\n  mute: string, // should be number\n  title: string,\n  message?: string,\n} & {\n  action?: 'mute1d' | 'push_settings', // will be set before postMessage to main thread\n};\n\nclass SomethingGetter<T extends Database<any>, Storage extends Record<string, any>> {\n  private cache: Partial<Storage> = {};\n  private storage: IDBStorage<T>;\n\n  constructor(\n    db: T,\n    storeName: typeof db['stores'][number]['name'],\n    private defaults: {\n      [Property in keyof Storage]: ((value: Storage[Property]) => Storage[Property]) | Storage[Property]\n    }\n  ) {\n    this.storage = new IDBStorage<T>(db, storeName);\n  }\n\n  private getDefault<T extends keyof Storage>(key: T) {\n    const callback = this.defaults[key];\n    return typeof(callback) === 'function' ? callback() : callback;\n  }\n\n  public get<T extends keyof Storage>(key: T) {\n    if(this.cache.hasOwnProperty(key)) {\n      return this.cache[key];\n    }\n\n    const promise = this.storage.get(key as string) as Promise<Storage[T]>;\n    return promise.then((value) => value, () => undefined as Storage[T]).then((value) => {\n      if(this.cache.hasOwnProperty(key)) {\n        return this.cache[key];\n      }\n\n      value ??= this.getDefault(key);\n\n      return this.cache[key] = value;\n    });\n  }\n\n  public getCached<T extends keyof Storage>(key: T) {\n    const value = this.get(key);\n    if(value instanceof Promise) {\n      throw 'no property';\n    }\n\n    return value;\n  }\n\n  public async set<T extends keyof Storage>(key: T, value: Storage[T]) {\n    const cached = this.cache[key] ?? this.defaults[key];\n    if(deepEqual(cached, value)) {\n      return;\n    }\n\n    this.cache[key] = value;\n\n    try {\n      this.storage.save(key as string, value);\n    } catch(err) {\n\n    }\n  }\n}\n\ntype PushStorage = {\n  push_mute_until: number,\n  push_lang: Partial<ServicePushPingTaskPayload['lang']>\n  push_settings: Partial<ServicePushPingTaskPayload['settings']>\n};\n\nconst defaults: PushStorage = {\n  push_mute_until: 0,\n  push_lang: {\n    push_message_nopreview: 'You have a new message',\n    push_action_mute1d: 'Mute for 24H',\n    push_action_settings: 'Settings'\n  },\n  push_settings: {}\n};\n\nconst getter = new SomethingGetter<typeof DATABASE_STATE, PushStorage>(DATABASE_STATE, 'session', defaults);\n\n// fill cache\nfor(const i in defaults) {\n  getter.get(i as keyof PushStorage);\n}\n\nctx.addEventListener('push', (event) => {\n  const obj: PushNotificationObject = event.data.json();\n  log('push', {...obj});\n\n  try {\n    const [muteUntil, settings, lang] = [\n      getter.getCached('push_mute_until'),\n      getter.getCached('push_settings'),\n      getter.getCached('push_lang')\n    ];\n\n    const nowTime = Date.now();\n    if(\n      userInvisibleIsSupported() &&\n      muteUntil &&\n      nowTime < muteUntil\n    ) {\n      throw `supress notification because mute for ${Math.ceil((muteUntil - nowTime) / 60000)} min`;\n    }\n\n    const hasActiveWindows = (Date.now() - lastPingTime) <= PING_PUSH_TIMEOUT && localNotificationsAvailable;\n    if(hasActiveWindows) {\n      throw 'supress notification because some instance is alive';\n    }\n\n    const notificationPromise = fireNotification(obj, settings, lang);\n    event.waitUntil(notificationPromise);\n  } catch(err) {\n    log(err);\n\n    // const tag = 'fix';\n    // const notificationPromise = ctx.registration.showNotification('Telegram', {tag});\n\n    // notificationPromise.then(() => {\n    //   closeAllNotifications(tag);\n    // });\n\n    // event.waitUntil(notificationPromise);\n  }\n});\n\nctx.addEventListener('notificationclick', (event) => {\n  const notification = event.notification;\n  log('on notification click', notification);\n  notification.close();\n\n  const action = event.action as PushNotificationObject['action'];\n  if(action === 'mute1d' && userInvisibleIsSupported()) {\n    log('[SW] mute for 1d');\n    getter.set('push_mute_until', Date.now() + 86400e3);\n    return;\n  }\n\n  const data: PushNotificationObject = notification.data;\n  if(!data) {\n    return;\n  }\n\n  const promise = ctx.clients.matchAll({\n    type: 'window'\n  }).then((clientList) => {\n    data.action = action;\n    pendingNotification = data;\n    for(let i = 0; i < clientList.length; ++i) {\n      const client = clientList[i];\n      if('focus' in client) {\n        client.focus();\n        serviceMessagePort.invokeVoid('pushClick', pendingNotification, client);\n        pendingNotification = undefined;\n        return;\n      }\n    }\n\n    if(ctx.clients.openWindow) {\n      return Promise.resolve(getter.get('push_settings')).then((settings) => {\n        return ctx.clients.openWindow(settings.baseUrl || defaultBaseUrl);\n      });\n    }\n  }).catch((error) => {\n    log.error('Clients.matchAll error', error);\n  })\n\n  event.waitUntil(promise);\n});\n\nctx.addEventListener('notificationclose', onCloseNotification);\n\nconst notifications: Set<Notification> = new Set();\nlet pendingNotification: PushNotificationObject;\nfunction pushToNotifications(notification: Notification) {\n  if(!notifications.has(notification)) {\n    notifications.add(notification);\n    // @ts-ignore\n    notification.onclose = onCloseNotification;\n  }\n}\n\nfunction onCloseNotification(event: NotificationEvent) {\n  removeFromNotifications(event.notification)\n}\n\nfunction removeFromNotifications(notification: Notification) {\n  notifications.delete(notification);\n}\n\nexport function closeAllNotifications(tag?: string) {\n  for(const notification of notifications) {\n    try {\n      if(tag && notification.tag !== tag) {\n        continue;\n      }\n\n      notification.close();\n      notifications.delete(notification);\n    } catch(e) {}\n  }\n\n  let promise: Promise<void>;\n  if('getNotifications' in ctx.registration) {\n    promise = ctx.registration.getNotifications({tag}).then((notifications) => {\n      for(let i = 0, len = notifications.length; i < len; ++i) {\n        try {\n          notifications[i].close();\n        } catch(e) {}\n      }\n    }).catch((error) => {\n      log.error('Offline register SW error', error);\n    });\n  } else {\n    promise = Promise.resolve();\n  }\n\n  return promise;\n}\n\nfunction userInvisibleIsSupported() {\n  return IS_FIREFOX;\n}\n\nfunction fireNotification(obj: PushNotificationObject, settings: PushStorage['push_settings'], lang: PushStorage['push_lang']) {\n  let title = obj.title || 'Telegram';\n  let body = obj.description || '';\n  let peerId: string;\n\n  if(obj.custom) {\n    if(obj.custom.channel_id) {\n      peerId = '' + -obj.custom.channel_id;\n    } else if(obj.custom.chat_id) {\n      peerId = '' + -obj.custom.chat_id;\n    } else {\n      peerId = obj.custom.from_id || '';\n    }\n  }\n\n  obj.custom.peerId = '' + peerId;\n  let tag = 'peer' + peerId;\n\n  const messageKey = peerId + '_' + obj.custom.msg_id;\n  if(ignoreMessages.has(messageKey)) {\n    const error = 'ignoring push';\n    log.warn(error, obj);\n    ignoreMessages.delete(messageKey);\n    throw error;\n  }\n\n  if(settings?.nopreview) {\n    title = 'Telegram';\n    body = lang.push_message_nopreview;\n    tag = 'unknown_peer';\n  }\n\n  const actions: (Omit<NotificationAction, 'action'> & {action: PushNotificationObject['action']})[] = [{\n    action: 'mute1d',\n    title: lang.push_action_mute1d\n  }/* , {\n    action: 'push_settings',\n    title: lang.push_action_settings || 'Settings'\n  } */];\n\n  const notificationOptions: NotificationOptions = {\n    body,\n    icon: NOTIFICATION_ICON_PATH,\n    tag,\n    data: obj,\n    actions,\n    badge: NOTIFICATION_BADGE_PATH,\n    silent: obj.custom.silent === '1'\n  };\n\n  log('show notify', title, body, obj, notificationOptions);\n\n  const notificationPromise = ctx.registration.showNotification(title, notificationOptions);\n\n  return notificationPromise.catch((error) => {\n    log.error('Show notification promise', error);\n  });\n}\n\nexport function onPing(payload: ServicePushPingTaskPayload, source?: MessageEventSource) {\n  lastPingTime = Date.now();\n  localNotificationsAvailable = payload.localNotifications;\n\n  if(pendingNotification && source) {\n    serviceMessagePort.invokeVoid('pushClick', pendingNotification, source);\n    pendingNotification = undefined;\n  }\n\n  if(payload.lang) {\n    getter.set('push_lang', payload.lang);\n  }\n\n  if(payload.settings) {\n    getter.set('push_settings', payload.settings);\n  }\n}\n\nconst ignoreMessages: Map<string, number> = new Map();\nexport function onShownNotification(payload: string) {\n  ignoreMessages.set(payload, Date.now());\n}\n\nsetInterval(() => {\n  const time = Date.now();\n  ignoreMessages.forEach((_time, key) => {\n    if((time - _time) > 30e3) {\n      ignoreMessages.delete(key);\n    }\n  });\n}, 30 * 60e3);\n","const tabId = Date.now() % Math.random() * 100000000 | 0;\nexport default tabId;\n","export default function indexOfAndSplice<T>(array: Array<T>, item: T) {\n  const idx = array.indexOf(item);\n  const spliced = idx === -1 ? undefined : array.splice(idx, 1);\n  return spliced?.[0];\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// import { MOUNT_CLASS_TO } from \"../config/debug\";\nimport type {ArgumentTypes, SuperReturnType} from '../types';\n\n// class EventSystem {\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\n\n//   add(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (listeners === undefined) {\n//         listeners = {};\n//     }\n//     let listenersForEvent = listeners[event];\n//     if (listenersForEvent === undefined) {\n//         listenersForEvent = new Set();\n//     }\n//     listenersForEvent.add(listener);\n//     listeners[event] = listenersForEvent;\n//     //target.addEventListener(event, listener);\n//     this.wm.set(target, listeners);\n//   };\n\n//   remove(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (!listeners) return;\n//     let listenersForEvent = listeners[event];\n//     if (!listenersForEvent) return;\n//     listenersForEvent.delete(listener);\n//   };\n\n//   /* fire(target, event) {\n//      let listeners = this.wm.get(target);\n//      if (!listeners) return;\n//      let listenersForEvent = listeners[event];\n//      if (!listenersForEvent) return;\n//      for (let handler of handlers) {\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous.\n//      }\n//   }; */\n// }\n\n// console.log = () => {};\n\n// const e = new EventSystem();\n// MOUNT_CLASS_TO.e = e;\n\nexport type EventListenerListeners = Record<string, Function>;\n// export type EventListenerListeners = Record<string, (...args: any[]) => any>;\n// export type EventListenerListeners = {[name in string]: Function};\n\n/**\n * Better not to remove listeners during setting\n * Should add listener callback only once\n */\n\ntype ListenerObject<T> = {callback: T, options: boolean | AddEventListenerOptions};\n\n// type EventLitenerCallback<T> = (data: T) =>\n// export default class EventListenerBase<Listeners extends {[name: string]: Function}> {\nexport default class EventListenerBase<Listeners extends EventListenerListeners> {\n  protected listeners: Partial<{\n    [k in keyof Listeners]: Set<ListenerObject<Listeners[k]>>\n  }>;\n  protected listenerResults: Partial<{\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\n  }>;\n\n  private reuseResults: boolean;\n\n  constructor(reuseResults?: boolean) {\n    this._constructor(reuseResults);\n  }\n\n  public _constructor(reuseResults?: boolean): any {\n    this.reuseResults = reuseResults;\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n\n  public addEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\n    const listenerObject: ListenerObject<Listeners[T]> = {callback, options};\n    (this.listeners[name] ??= new Set()).add(listenerObject); // ! add before because if you don't, you won't be able to delete it from callback\n\n    if(this.listenerResults.hasOwnProperty(name)) {\n      callback(...this.listenerResults[name]);\n\n      if((options as AddEventListenerOptions)?.once) {\n        this.listeners[name].delete(listenerObject);\n        return;\n      }\n    }\n\n    // e.add(this, name, {callback, once});\n  }\n\n  public addMultipleEventsListeners(obj: {\n    [name in keyof Listeners]?: Listeners[name]\n  }) {\n    for(const i in obj) {\n      this.addEventListener(i, obj[i]);\n    }\n  }\n\n  public removeEventListener<T extends keyof Listeners>(\n    name: T,\n    callback: Listeners[T],\n    options?: boolean | AddEventListenerOptions\n  ) {\n    if(this.listeners[name]) {\n      for(const l of this.listeners[name]) {\n        if(l.callback === callback) {\n          this.listeners[name].delete(l);\n          break;\n        }\n      }\n    }\n    // e.remove(this, name, callback);\n  }\n\n  protected invokeListenerCallback<T extends keyof Listeners, L extends ListenerObject<any>>(\n    name: T,\n    listener: L,\n    ...args: ArgumentTypes<L['callback']>\n  ) {\n    let result: any, error: any;\n    try {\n      result = listener.callback(...args);\n    } catch(err) {\n      error = err;\n      // console.error('listener callback error', err);\n    }\n\n    if((listener.options as AddEventListenerOptions)?.once) {\n      this.removeEventListener(name, listener.callback);\n    }\n\n    if(error) {\n      throw error;\n    }\n\n    return result;\n  }\n\n  private _dispatchEvent<T extends keyof Listeners>(\n    name: T,\n    collectResults: boolean,\n    ...args: ArgumentTypes<Listeners[T]>\n  ) {\n    if(this.reuseResults) {\n      this.listenerResults[name] = args;\n    }\n\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = collectResults && [];\n\n    const listeners = this.listeners[name];\n    if(listeners) {\n      for(const listener of listeners) {\n        const result = this.invokeListenerCallback(name, listener, ...args);\n        if(arr) {\n          arr.push(result);\n        }\n      }\n    }\n\n    return arr;\n  }\n\n  public dispatchResultableEvent<T extends keyof Listeners>(name: T, ...args: ArgumentTypes<Listeners[T]>) {\n    return this._dispatchEvent(name, true, ...args);\n  }\n\n  // * must be protected, but who cares\n  public dispatchEvent<L extends EventListenerListeners = Listeners, T extends keyof L = keyof L>(\n    name: T,\n    ...args: ArgumentTypes<L[T]>\n  ) {\n    // @ts-ignore\n    this._dispatchEvent(name, false, ...args);\n  }\n\n  public cleanup() {\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from '../../config/debug';\nimport tabId from '../../config/tabId';\nimport ctx from '../../environment/ctx';\nimport indexOfAndSplice from '../../helpers/array/indexOfAndSplice';\nimport {IS_WORKER} from '../../helpers/context';\nimport EventListenerBase from '../../helpers/eventListenerBase';\nimport makeError from '../../helpers/makeError';\nimport {Awaited, WorkerTaskTemplate, WorkerTaskVoidTemplate} from '../../types';\nimport {logger} from '../logger';\n\ntype SuperMessagePortTask = WorkerTaskTemplate & {\n  transfer?: Transferable[]\n};\n\ninterface InvokeTask extends SuperMessagePortTask {\n  type: 'invoke',\n  payload: WorkerTaskVoidTemplate & {withAck?: boolean, void?: boolean}\n}\n\ninterface ResultTask extends SuperMessagePortTask {\n  type: 'result',\n  payload: {\n    taskId: number,\n    result?: any,\n    error?: any\n  }\n}\n\ninterface AckTask extends SuperMessagePortTask {\n  type: 'ack',\n  payload: {\n    cached: boolean,\n    taskId: number\n    result?: any,\n    error?: any,\n  }\n}\n\ninterface PingTask extends SuperMessagePortTask {\n  type: 'ping'\n}\n\ninterface PongTask extends SuperMessagePortTask {\n  type: 'pong'\n}\n\ninterface BatchTask extends SuperMessagePortTask {\n  type: 'batch',\n  payload: Task[]\n}\n\ninterface CloseTask extends SuperMessagePortTask {\n  type: 'close'\n}\n\n// interface OpenTask extends SuperMessagePortTask {\n//   type: 'open'\n// }\n\ninterface LockTask extends SuperMessagePortTask {\n  type: 'lock',\n  payload: string\n}\n\ntype Task = InvokeTask | ResultTask | AckTask | PingTask | PongTask | BatchTask | CloseTask/*  | OpenTask */ | LockTask;\ntype TaskMap = {\n  [type in Task as type['type']]?: (task: Extract<Task, type>, source: MessageEventSource, event: MessageEvent<any>) => void | Promise<any>\n};\n\nexport type AckedResult<T> = {\n  cached: boolean,\n  result: Promise<T>\n};\n// export type AckedResult<T> = {\n//   cached: true,\n//   result: T\n// } | {\n//   cached: false,\n//   result: Promise<T>\n// };\n\ntype ListenPort = WindowProxy | MessagePort | ServiceWorker | Worker | ServiceWorkerContainer;\ntype SendPort = Pick<MessageEventSource, 'postMessage'>/* WindowProxy | MessagePort | ServiceWorker | Worker */;\n\nexport type MessageListenPort = ListenPort;\nexport type MessageSendPort = SendPort;\n\ntype ListenerCallback = (payload: any, source: MessageEventSource, event: MessageEvent<any>) => any;\ntype Listeners = Record<string, ListenerCallback>;\n\nconst USE_LOCKS = true;\nconst USE_BATCHING = true;\n\n// const PING_INTERVAL = DEBUG && false ? 0x7FFFFFFF : 5000;\n// const PING_TIMEOUT = DEBUG && false ? 0x7FFFFFFF : 10000;\n\nexport default class SuperMessagePort<\n  Workers extends Listeners,\n  Masters extends Listeners,\n  IsMaster extends boolean,\n  Receive extends Listeners = IsMaster extends true ? Masters : Workers,\n  Send extends Listeners = IsMaster extends true ? Workers : Masters\n> extends EventListenerBase<Receive> {\n  protected listenPorts: Array<ListenPort>;\n  protected sendPorts: Array<SendPort>;\n  protected pingResolves: Map<SendPort, () => void>;\n\n  protected taskId: number;\n  protected awaiting: {\n    [id: number]: {\n      resolve: any,\n      reject: any,\n      taskType: string,\n      port?: SendPort\n    }\n  };\n  protected pending: Map<SendPort, Task[]>;\n\n  protected log: ReturnType<typeof logger>;\n  protected debug: boolean;\n  protected releasingPending: boolean;\n\n  protected processTaskMap: TaskMap;\n\n  protected onPortDisconnect: (source: MessageEventSource) => void;\n  // protected onPortConnect: (source: MessageEventSource) => void;\n\n  protected heldLocks: Map<SendPort, {resolve: () => void, id: string}>;\n  protected requestedLocks: Map<string, SendPort>;\n\n  constructor(protected logSuffix?: string) {\n    super(false);\n\n    this.listenPorts = [];\n    this.sendPorts = [];\n    this.pingResolves = new Map();\n    this.taskId = 0;\n    this.awaiting = {};\n    this.pending = new Map();\n    this.log = logger('MP' + (logSuffix ? '-' + logSuffix : ''));\n    this.debug = DEBUG;\n    this.heldLocks = new Map();\n    this.requestedLocks = new Map();\n\n    this.processTaskMap = {\n      result: this.processResultTask,\n      ack: this.processAckTask,\n      invoke: this.processInvokeTask,\n      ping: this.processPingTask,\n      pong: this.processPongTask,\n      close: this.processCloseTask,\n      // open: this.processOpenTask,\n      lock: this.processLockTask,\n      batch: this.processBatchTask\n    };\n  }\n\n  public setOnPortDisconnect(callback: (source: MessageEventSource) => void) {\n    this.onPortDisconnect = callback;\n  }\n\n  // public setOnPortConnect(callback: (source: MessageEventSource) => void) {\n  //   this.onPortConnect = callback;\n  // }\n\n  public attachPort(port: MessageEventSource) {\n    this.attachListenPort(port);\n    this.attachSendPort(port);\n  }\n\n  public attachListenPort(port: ListenPort) {\n    this.listenPorts.push(port);\n    port.addEventListener('message', this.onMessage as any);\n  }\n\n  public attachSendPort(port: SendPort) {\n    this.log.warn('attaching send port');\n\n    (port as MessagePort).start?.();\n\n    this.sendPorts.push(port);\n    // this.sendPing(port);\n\n    // const task = this.createTask('open', undefined);\n    // this.postMessage(port, task);\n\n    if(typeof(window) !== 'undefined' && USE_LOCKS) {\n      if('locks' in navigator) {\n        const id = ['lock', tabId, this.logSuffix || '', Math.random() * 0x7FFFFFFF | 0].join('-');\n        this.log.warn('created lock', id);\n        const promise = new Promise<void>((resolve) => this.heldLocks.set(port, {resolve, id}))\n        .then(() => this.heldLocks.delete(port));\n        navigator.locks.request(id, () => {\n          this.resendLockTask(port);\n          return promise;\n        });\n      } else {\n        window.addEventListener('beforeunload', () => {\n          const task = this.createTask('close', undefined);\n          this.postMessage(undefined, task);\n        });\n      }\n    }\n\n    this.releasePending();\n  }\n\n  public resendLockTask(port: SendPort) {\n    const lock = this.heldLocks.get(port);\n    if(!lock) {\n      return;\n    }\n\n    this.pushTask(this.createTask('lock', lock.id), port);\n  }\n\n  // ! Can't rely on ping because timers can be suspended\n  // protected sendPing(port: SendPort, loop = IS_WORKER) {\n  //   let timeout: number;\n  //   const promise = new Promise<void>((resolve, reject) => {\n  //     this.pingResolves.set(port, resolve);\n  //     this.pushTask(this.createTask('ping', undefined), port);\n\n  //     timeout = ctx.setTimeout(() => {\n  //       reject();\n  //     }, PING_TIMEOUT);\n  //   });\n\n  //   promise.then(() => {\n  //     // this.log('got pong');\n\n  //     clearTimeout(timeout);\n  //     this.pingResolves.delete(port);\n\n  //     if(loop) {\n  //       this.sendPingWithTimeout(port);\n  //     }\n  //   }, () => {\n  //     this.pingResolves.delete(port);\n  //     this.detachPort(port);\n  //   });\n  // }\n\n  // protected sendPingWithTimeout(port: SendPort, timeout = PING_INTERVAL) {\n  //   ctx.setTimeout(() => {\n  //     if(!this.sendPorts.includes(port)) {\n  //       return;\n  //     }\n\n  //     this.sendPing(port);\n  //   }, timeout);\n  // }\n\n  public detachPort(port: ListenPort) {\n    this.log.warn('disconnecting port');\n\n    indexOfAndSplice(this.listenPorts, port);\n    indexOfAndSplice(this.sendPorts, port as any);\n\n    port.removeEventListener?.('message', this.onMessage as any);\n    (port as MessagePort).close?.();\n\n    this.onPortDisconnect?.(port as any);\n\n    const heldLock = this.heldLocks.get(port as SendPort);\n    heldLock?.resolve();\n\n    const error = makeError('PORT_DISCONNECTED');\n    for(const id in this.awaiting) {\n      const task = this.awaiting[id];\n      if(task.port === port) {\n        task.reject(error);\n        delete this.awaiting[id];\n      }\n    }\n  }\n\n  protected postMessage(port: SendPort | SendPort[], task: Task) {\n    const ports = Array.isArray(port) ? port : (port ? [port] : this.sendPorts);\n    ports.forEach((port) => {\n      if(import.meta.env.MODE === 'test') {\n        return;\n      }\n\n      port.postMessage(task, task.transfer as any);\n    });\n  }\n\n  protected onMessage = (event: MessageEvent) => {\n    const task: Task = event.data;\n    // this.log('got message', task);\n\n    const source: MessageEventSource = event.source || event.currentTarget as any; // can have no source\n\n    // @ts-ignore\n    this.processTaskMap[task.type](task, source, event);\n  };\n\n  protected async releasePending() {\n    // return;\n\n    if(/* !this.listenPorts.length || !this.sendPorts.length ||  */this.releasingPending) {\n      return;\n    }\n\n    this.releasingPending = true;\n    // const perf = performance.now();\n\n    if(USE_BATCHING) {\n      await Promise.resolve();\n    }\n    // await pause(0);\n\n    this.debug && this.log.debug('releasing tasks, length:', this.pending.size/* , performance.now() - perf */);\n\n    this.pending.forEach((portTasks, port) => {\n      let tasks: Task[] = portTasks;\n      if(USE_BATCHING) {\n        let batchTask: BatchTask;\n        tasks = [];\n        portTasks.forEach((task) => {\n          if(task.transfer) {\n            batchTask = undefined;\n            tasks.push(task);\n          } else {\n            if(!batchTask) {\n              batchTask = this.createTask('batch', []);\n              tasks.push(batchTask);\n            }\n\n            batchTask.payload.push(task);\n          }\n        });\n      }\n\n      const ports = port ? [port] : this.sendPorts;\n      if(!ports.length) {\n        return;\n      }\n\n      tasks.forEach((task) => {\n        // if(USE_BATCHING && task.type === 'batch') {\n        //   this.log(`batching ${task.payload.length} tasks`);\n        // }\n\n        try {\n          // if(IS_SERVICE_WORKER && !port) {\n          //   notifyAll(task);\n          // } else {\n          this.postMessage(ports, task);\n          // }\n        } catch(err) {\n          this.log.error('postMessage error:', err, task, ports);\n        }\n      });\n\n      this.pending.delete(port);\n    });\n\n    this.debug && this.log.debug('released tasks');\n\n    this.releasingPending = false;\n  }\n\n  protected processResultTask = (task: ResultTask) => {\n    const {taskId, result, error} = task.payload;\n    const deferred = this.awaiting[taskId];\n    if(!deferred) {\n      return;\n    }\n\n    this.debug && this.log.debug('done', deferred.taskType, result, error);\n    'error' in task.payload ? deferred.reject(error) : deferred.resolve(result);\n    delete this.awaiting[taskId];\n  };\n\n  protected processAckTask = (task: AckTask) => {\n    const payload = task.payload;\n    const deferred = this.awaiting[payload.taskId];\n    if(!deferred) {\n      return;\n    }\n\n    // * will finish the init promise with incoming result\n    const previousResolve: (acked: AckedResult<any>) => void = deferred.resolve;\n    // const previousReject = deferred.reject;\n\n    // if(payload.cached) {\n    //   if('result' in payload) {\n    //     previousResolve({\n    //       cached: true,\n    //       result: payload.result\n    //     });\n    //   } else {\n    //     previousReject(payload.error);\n    //   }\n    // } else {\n    //   const ret: AckedResult<any> = {\n    //     cached: false,\n    //     result: new Promise((resolve, reject) => {\n    //       deferred.resolve = resolve;\n    //       deferred.reject = reject;\n    //     })\n    //   };\n\n    //   previousResolve(ret);\n    // }\n\n    const ret: AckedResult<any> = {\n      cached: payload.cached,\n      result: payload.cached ? ('result' in payload ? Promise.resolve(payload.result) : Promise.reject(payload.error)) : new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n      })\n    };\n\n    previousResolve(ret);\n\n    if(payload.cached) {\n      delete this.awaiting[payload.taskId];\n    }\n  };\n\n  protected processPingTask = (task: PingTask, source: MessageEventSource, event: MessageEvent) => {\n    this.pushTask(this.createTask('pong', undefined), event.source);\n  };\n\n  protected processPongTask = (task: PongTask, source: MessageEventSource, event: MessageEvent) => {\n    const pingResolve = this.pingResolves.get(source);\n    if(pingResolve) {\n      this.pingResolves.delete(source);\n      pingResolve();\n    }\n  };\n\n  protected processCloseTask = (task: CloseTask, source: MessageEventSource, event: MessageEvent) => {\n    this.detachPort(source);\n  };\n\n  protected processBatchTask = (task: BatchTask, source: MessageEventSource, event: MessageEvent) => {\n    if(!USE_BATCHING) {\n      return;\n    }\n\n    const newEvent: MessageEvent = {data: event.data, source: event.source, currentTarget: event.currentTarget} as any;\n    task.payload.forEach((task) => {\n      // @ts-ignore\n      newEvent.data = task;\n      this.onMessage(newEvent);\n    });\n  };\n\n  // * it's just an 'open' callback, DO NOT attach port from here\n  // protected processOpenTask = (task: OpenTask, source: MessageEventSource, event: MessageEvent) => {\n  //   this.onPortConnect?.(source);\n  // };\n\n  protected processLockTask = (task: LockTask, source: MessageEventSource, event: MessageEvent) => {\n    const id = task.payload;\n    if(this.requestedLocks.has(id)) {\n      return;\n    }\n\n    this.requestedLocks.set(id, source);\n    navigator.locks.request(id, () => {\n      this.processCloseTask(undefined, source, undefined);\n      this.requestedLocks.delete(id);\n    });\n  };\n\n  protected processInvokeTask = async(task: InvokeTask, source: MessageEventSource, event: MessageEvent) => {\n    const id = task.id;\n    const innerTask = task.payload;\n\n    let resultTaskPayload: ResultTask['payload'];\n    let resultTask: ResultTask, ackTask: AckTask;\n    if(!innerTask.void) {\n      resultTaskPayload = {taskId: id};\n      resultTask = this.createTask('result', resultTaskPayload);\n    }\n\n    if(innerTask.withAck) {\n      ackTask = this.createTask('ack', {\n        taskId: id,\n        cached: true\n      });\n    }\n\n    let isPromise: boolean;\n    try {\n      const listeners = this.listeners[innerTask.type];\n      if(!listeners?.size) {\n        throw new Error('no listener');\n      }\n\n      const listener = listeners.values().next().value;\n\n      // @ts-ignore\n      let result = this.invokeListenerCallback(innerTask.type, listener, innerTask.payload, source, event);\n      if(innerTask.void) {\n        return;\n      }\n\n      isPromise = result instanceof Promise;\n\n      if(ackTask) {\n        const cached = !isPromise;\n        ackTask.payload.cached = cached;\n        if(cached) ackTask.payload.result = result;\n        this.pushTask(ackTask, source);\n\n        if(cached) {\n          return;\n        }\n      }\n\n      if(isPromise) {\n        result = await result;\n      }\n\n      resultTaskPayload.result = result;\n    } catch(error) {\n      this.log.error('worker task error:', error, task);\n      if(innerTask.void) {\n        return;\n      }\n\n      if(ackTask && ackTask.payload.cached) {\n        ackTask.payload.error = error;\n        this.pushTask(ackTask, source);\n        return;\n      }\n\n      resultTaskPayload.error = error;\n    }\n\n    this.pushTask(resultTask, source);\n  };\n\n  protected createTask<T extends Task['type'], K extends Task = Parameters<TaskMap[T]>[0]>(type: T, payload: K['payload'], transfer?: Transferable[]): K {\n    return {\n      type,\n      payload,\n      id: this.taskId++,\n      transfer\n    } as K;\n  }\n\n  protected createInvokeTask(type: string, payload: any, withAck?: boolean, _void?: boolean, transfer?: Transferable[]): InvokeTask {\n    return this.createTask('invoke', {\n      type,\n      payload,\n      withAck,\n      void: _void\n    }, transfer);\n  }\n\n  protected pushTask(task: Task, port?: SendPort) {\n    let tasks = this.pending.get(port);\n    if(!tasks) {\n      this.pending.set(port, tasks = []);\n    }\n\n    tasks.push(task);\n    this.releasePending();\n  }\n\n  public invokeVoid<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], port?: SendPort, transfer?: Transferable[]) {\n    const task = this.createInvokeTask(type as string, payload, undefined, true, transfer);\n    this.pushTask(task, port);\n  }\n\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: false, port?: SendPort, transfer?: Transferable[]): Promise<Awaited<ReturnType<Send[T]>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: true, port?: SendPort, transfer?: Transferable[]): Promise<AckedResult<Awaited<ReturnType<Send[T]>>>>;\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: boolean, port?: SendPort, transfer?: Transferable[]) {\n    this.debug && this.log.debug('start', type, payload);\n\n    let task: InvokeTask;\n    const promise = new Promise<Awaited<ReturnType<Send[T]>>>((resolve, reject) => {\n      task = this.createInvokeTask(type as string, payload, withAck, undefined, transfer);\n      this.awaiting[task.id] = {resolve, reject, taskType: type as string, port};\n      this.pushTask(task, port);\n    });\n\n    if(IS_WORKER) {\n      promise.finally(() => {\n        clearInterval(interval);\n      });\n\n      const interval = ctx.setInterval(() => {\n        this.log.error('task still has no result', task, port);\n      }, 60e3);\n    } else if(false) {\n      // let timedOut = false;\n      const startTime = Date.now();\n      promise.finally(() => {\n        const elapsedTime = Date.now() - startTime;\n        if(elapsedTime >= TIMEOUT) {\n          this.log.error(`task was processing ${Date.now() - startTime}ms`, task.payload.payload, port);\n        }/*  else {\n          clearTimeout(timeout);\n        } */\n      });\n\n      const TIMEOUT = 10;\n      // const timeout = ctx.setTimeout(() => {\n      //   timedOut = true;\n      //   // this.log.error(`task is processing more than ${TIMEOUT} milliseconds`, task, port);\n      // }, TIMEOUT);\n    }\n\n    return promise;\n  }\n\n  public invokeExceptSource<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], source?: SendPort) {\n    const ports = this.sendPorts.slice();\n    indexOfAndSplice(ports, source);\n\n    ports.forEach((target) => {\n      this.invokeVoid(type, payload, target);\n    });\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {WebPushApiManager} from '../mtproto/webPushApiManager';\nimport type {PushNotificationObject} from './push';\nimport type {MyUploadFile} from '../mtproto/apiFileManager';\nimport SuperMessagePort from '../mtproto/superMessagePort';\nimport {MOUNT_CLASS_TO} from '../../config/debug';\n\nexport type ServicePushPingTaskPayload = {\n  localNotifications: boolean,\n  lang: {\n    push_action_mute1d: string\n    push_action_settings: string\n    push_message_nopreview: string\n  },\n  settings: WebPushApiManager['settings']\n};\n\nexport type ServiceRequestFilePartTaskPayload = {\n  docId: DocId,\n  dcId: number,\n  offset: number,\n  limit: number\n};\n\nexport type ServiceDownloadTaskPayload = {\n  headers: any,\n  id: string\n};\n\nexport type ServiceEvent = {\n  port: (payload: void, source: MessageEventSource, event: MessageEvent) => void\n};\n\nexport default class ServiceMessagePort<Master extends boolean = false> extends SuperMessagePort<{\n  // from main thread to service worker\n  notificationsClear: () => void,\n  toggleStorages: (payload: {enabled: boolean, clearWrite: boolean}) => void,\n  pushPing: (payload: ServicePushPingTaskPayload, source: MessageEventSource, event: MessageEvent) => void,\n  hello: (payload: void, source: MessageEventSource, event: MessageEvent) => void,\n  shownNotification: (payload: string) => void,\n\n  // from mtproto worker\n  download: (payload: ServiceDownloadTaskPayload) => void,\n  downloadChunk: (payload: {id: ServiceDownloadTaskPayload['id'], chunk: Uint8Array}) => void\n  downloadFinalize: (payload: ServiceDownloadTaskPayload['id']) => void,\n  downloadCancel: (payload: ServiceDownloadTaskPayload['id']) => void\n}, {\n  // to main thread\n  pushClick: (payload: PushNotificationObject) => void,\n  hello: (payload: void, source: MessageEventSource) => void,\n  share: (payload: ShareData) => void,\n\n  // to mtproto worker\n  requestFilePart: (payload: ServiceRequestFilePartTaskPayload) => Promise<MyUploadFile> | MyUploadFile\n} & ServiceEvent, Master> {\n  constructor() {\n    super('SERVICE');\n\n    MOUNT_CLASS_TO && (MOUNT_CLASS_TO.serviceMessagePort = this);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type SuperMessagePort from '../lib/mtproto/superMessagePort';\nimport ctx from '../environment/ctx';\n\nexport default function listenMessagePort(\n  messagePort: SuperMessagePort<any, any, any>,\n  onConnect?: (source: MessageEventSource) => void,\n  onDisconnect?: (source: MessageEventSource) => void\n) {\n  const attachPort = (listenPort: any, sendPort: any) => {\n    messagePort.attachListenPort(listenPort);\n    sendPort && messagePort.attachSendPort(sendPort);\n    onConnect?.(listenPort);\n  };\n\n  messagePort.setOnPortDisconnect(onDisconnect);\n\n  if(typeof(SharedWorkerGlobalScope) !== 'undefined') {\n    (ctx as any as SharedWorkerGlobalScope).addEventListener('connect', (e) => attachPort(e.source, e.source));\n  } else if(typeof(ServiceWorkerGlobalScope) !== 'undefined') {\n    attachPort(ctx, null);\n  } else {\n    attachPort(ctx, ctx);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type {ServiceDownloadTaskPayload} from './serviceMessagePort';\nimport type ServiceMessagePort from './serviceMessagePort';\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\nimport makeError from '../../helpers/makeError';\nimport pause from '../../helpers/schedulers/pause';\n\ntype DownloadType = Uint8Array;\ntype DownloadItem = ServiceDownloadTaskPayload & {\n  // transformStream: TransformStream<DownloadType, DownloadType>,\n  readableStream: ReadableStream<DownloadType>,\n  // writableStream: WritableStream<DownloadType>,\n  // writer: WritableStreamDefaultWriter<DownloadType>,\n  // controller: TransformStreamDefaultController<DownloadType>,\n  controller: ReadableStreamController<Uint8Array>,\n  promise: CancellablePromise<void>,\n  // downloadPromise: Promise<void>,\n  used?: boolean\n};\nconst downloadMap: Map<string, DownloadItem> = new Map();\nconst DOWNLOAD_ERROR = makeError('UNKNOWN');\nconst DOWNLOAD_TEST = false;\n\n(self as any).downloadMap = downloadMap;\n\ntype A = Parameters<ServiceMessagePort<false>['addMultipleEventsListeners']>[0];\n\nconst events: A = {\n  download: (payload) => {\n    const {id} = payload;\n    if(downloadMap.has(id)) {\n      return Promise.reject(DOWNLOAD_ERROR);\n    }\n\n    // const y = (20 * 1024 * 1024) / payload.limitPart;\n    // const strategy = new ByteLengthQueuingStrategy({highWaterMark: y});\n    // let controller: TransformStreamDefaultController<DownloadType>;\n    const strategy = new CountQueuingStrategy({highWaterMark: 1});\n    // const transformStream = new TransformStream<DownloadType, DownloadType>(/* {\n    //   start: (_controller) => controller = _controller,\n    // },  */undefined, strategy, strategy);\n\n    // const {readable, writable} = transformStream;\n    // const writer = writable.getWriter();\n\n    const promise = deferredPromise<void>();\n    promise.then(() => {\n      setTimeout(() => {\n        downloadMap.delete(id);\n      }, 5e3);\n    }, () => {\n      downloadMap.delete(id);\n    });\n\n    // writer.closed.then(promise.resolve, promise.reject);\n\n    let controller: ReadableStreamController<any>;\n    const readable = new ReadableStream({\n      start: (_controller) => {\n        controller = _controller;\n      },\n\n      cancel: (reason) => {\n        promise.reject(DOWNLOAD_ERROR);\n      }\n    }, strategy);\n\n    // writer.closed.catch(noop).finally(() => {\n    //   log.error('closed writer');\n    //   onEnd();\n    // });\n\n    // const downloadPromise = writer.closed.catch(() => {throw DOWNLOAD_ERROR;});\n    const item: DownloadItem = {\n      ...payload,\n      // transformStream,\n      readableStream: readable,\n      // writableStream: writable,\n      // writer,\n      // downloadPromise,\n      promise,\n      controller\n    };\n\n    downloadMap.set(id, item);\n\n    // return downloadPromise;\n    return promise.catch(() => {throw DOWNLOAD_ERROR});\n  },\n\n  downloadChunk: ({id, chunk}) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return Promise.reject();\n    }\n\n    // return item.controller.enqueue(chunk);\n    // return item.writer.write(chunk);\n    // @ts-ignore\n    return item.controller.enqueue(chunk);\n  },\n\n  downloadFinalize: (id) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return Promise.reject();\n    }\n\n    item.promise.resolve();\n    // return item.controller.terminate();\n    // return item.writer.close();\n    return item.controller.close();\n  },\n\n  downloadCancel: (id) => {\n    const item = downloadMap.get(id);\n    if(!item) {\n      return;\n    }\n\n    item.promise.reject();\n    // return item.controller.error();\n    // return item.writer.abort();\n    return item.controller.error();\n  }\n};\n\nexport default function handleDownload(serviceMessagePort: ServiceMessagePort<false>) {\n  serviceMessagePort.addMultipleEventsListeners(events);\n\n  return {\n    onDownloadFetch,\n    onClosedWindows: cancelAllDownloads\n  };\n}\n\nfunction onDownloadFetch(event: FetchEvent, params: string) {\n  const promise = pause(100).then(() => {\n    const item = downloadMap.get(params);\n    if(!item || (item.used && !DOWNLOAD_TEST)) {\n      return;\n    }\n\n    item.used = true;\n    const stream = item.readableStream;\n    const response = new Response(stream, {headers: item.headers});\n    return response;\n  });\n\n  event.respondWith(promise);\n}\n\nfunction cancelAllDownloads() {\n  if(downloadMap.size) {\n    for(const [id, item] of downloadMap) {\n      // item.writer.abort().catch(noop);\n      item.controller.error();\n    }\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {log, serviceMessagePort} from './index.service';\n\nconst deferred: {[id: string]: ShareData[]} = {};\n\nfunction parseFormData(formData: FormData): ShareData {\n  return {\n    files: formData.getAll('files') as File[],\n    title: formData.get('title') as string,\n    text: formData.get('text') as string,\n    url: formData.get('url') as string\n  };\n}\n\nasync function processShareEvent(formData: FormData, clientId: string) {\n  try {\n    log('share data', formData);\n    const data = parseFormData(formData);\n    (deferred[clientId] ??= []).push(data);\n  } catch(err) {\n    log.warn('something wrong with the data', err);\n  }\n};\n\nexport function checkWindowClientForDeferredShare(windowClient: WindowClient) {\n  const arr = deferred[windowClient.id];\n  if(!arr) {\n    return;\n  }\n\n  delete deferred[windowClient.id];\n\n  log('releasing share events to client:', windowClient.id, 'length:', arr.length);\n  arr.forEach((data) => {\n    serviceMessagePort.invokeVoid('share', data, windowClient);\n  });\n}\n\nexport default function onShareFetch(event: FetchEvent, params: string) {\n  const promise = event.request.formData()\n  .then((formData) => {\n    processShareEvent(formData, event.resultingClientId)\n    return Response.redirect('..');\n  });\n\n  event.respondWith(promise);\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {logger, LogTypes} from '../logger';\nimport {CACHE_ASSETS_NAME, requestCache} from './cache';\nimport onStreamFetch from './stream';\nimport {closeAllNotifications, onPing, onShownNotification} from './push';\nimport CacheStorageController from '../files/cacheStorage';\nimport {IS_SAFARI} from '../../environment/userAgent';\nimport ServiceMessagePort from './serviceMessagePort';\nimport listenMessagePort from '../../helpers/listenMessagePort';\nimport {getWindowClients} from '../../helpers/context';\nimport {MessageSendPort} from '../mtproto/superMessagePort';\nimport handleDownload from './download';\nimport onShareFetch, {checkWindowClientForDeferredShare} from './share';\n\n// #if MTPROTO_SW\n// import '../mtproto/mtproto.worker';\n// #endif\n\nexport const log = logger('SW', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn, true);\nconst ctx = self as any as ServiceWorkerGlobalScope;\n\n// #if !MTPROTO_SW\nlet _mtprotoMessagePort: MessagePort;\nexport const getMtprotoMessagePort = () => _mtprotoMessagePort;\n\nlog('init');\n\nconst sendMessagePort = (source: MessageSendPort) => {\n  const channel = new MessageChannel();\n  serviceMessagePort.attachPort(_mtprotoMessagePort = channel.port1);\n  serviceMessagePort.invokeVoid('port', undefined, source, [channel.port2]);\n};\n\nconst sendMessagePortIfNeeded = (source: MessageSendPort) => {\n  if(!connectedWindows.size && !_mtprotoMessagePort) {\n    log('sending message port for mtproto');\n    sendMessagePort(source);\n  }\n};\n\nconst onWindowConnected = (source: WindowClient) => {\n  log('window connected', source.id, 'windows before', connectedWindows.size);\n\n  if(source.frameType === 'none') {\n    log.warn('maybe a bugged Safari starting window', source.id);\n    return;\n  }\n\n  log('windows', Array.from(connectedWindows));\n  serviceMessagePort.invokeVoid('hello', undefined, source);\n  sendMessagePortIfNeeded(source);\n  connectedWindows.set(source.id, source);\n\n  checkWindowClientForDeferredShare(source);\n};\n\nexport const serviceMessagePort = new ServiceMessagePort<false>();\nserviceMessagePort.addMultipleEventsListeners({\n  notificationsClear: closeAllNotifications,\n\n  toggleStorages: ({enabled, clearWrite}) => {\n    CacheStorageController.toggleStorage(enabled, clearWrite);\n  },\n\n  pushPing: (payload, source) => {\n    onPing(payload, source);\n  },\n\n  hello: (payload, source) => {\n    onWindowConnected(source as any as WindowClient);\n  },\n\n  shownNotification: onShownNotification\n});\n\nconst {\n  onDownloadFetch,\n  onClosedWindows: onDownloadClosedWindows\n} = handleDownload(serviceMessagePort);\n\n// * service worker can be killed, so won't get 'hello' event\ngetWindowClients().then((windowClients) => {\n  log(`got ${windowClients.length} windows from the start`);\n  windowClients.forEach((windowClient) => {\n    onWindowConnected(windowClient);\n  });\n});\n\nconst connectedWindows: Map<string, WindowClient> = new Map();\n(self as any).connectedWindows = connectedWindows;\nlistenMessagePort(serviceMessagePort, undefined, (source) => {\n  log('something has disconnected', source);\n  const isWindowClient = source instanceof WindowClient;\n  if(!isWindowClient || !connectedWindows.has(source.id)) {\n    log.warn('it is not a window');\n    return;\n  }\n\n  connectedWindows.delete(source.id);\n  log('window disconnected, left', connectedWindows.size);\n  if(!connectedWindows.size) {\n    log.warn('no windows left');\n\n    if(_mtprotoMessagePort) {\n      serviceMessagePort.detachPort(_mtprotoMessagePort);\n      _mtprotoMessagePort = undefined;\n    }\n\n    onDownloadClosedWindows();\n  }\n});\n// #endif\n\nconst onFetch = (event: FetchEvent): void => {\n  if(\n    import.meta.env.PROD &&\n    !IS_SAFARI &&\n    event.request.url.indexOf(location.origin + '/') === 0 &&\n    event.request.url.match(/\\.(js|css|jpe?g|json|wasm|png|mp3|svg|tgs|ico|woff2?|ttf|webmanifest?)(?:\\?.*)?$/)\n  ) {\n    return event.respondWith(requestCache(event));\n  }\n\n  if(import.meta.env.DEV && event.request.url.endsWith('.ts')) {\n    return;\n  }\n\n  try {\n    // const [, url, scope, params] = /http[:s]+\\/\\/.*?(\\/(.*?)(?:$|\\/(.*)$))/.exec(event.request.url) || [];\n    const [scope, _params] = event.request.url.split('/').slice(-2);\n    const [params, search] = _params.split('?');\n\n    // log.debug('[fetch]:', event);\n\n    switch(scope) {\n      case 'stream': {\n        onStreamFetch(event, params, search);\n        break;\n      }\n\n      case 'download': {\n        onDownloadFetch(event, params);\n        break;\n      }\n\n      case 'share': {\n        onShareFetch(event, params);\n        break;\n      }\n\n      case 'ping': {\n        event.respondWith(new Response('pong'));\n        break;\n      }\n\n      // default: {\n      //   event.respondWith(fetch(event.request));\n      //   break;\n      // }\n    }\n  } catch(err) {\n    log.error('fetch error', err);\n    event.respondWith(new Response('', {\n      status: 500,\n      statusText: 'Internal Server Error',\n      headers: {'Cache-Control': 'no-cache'}\n    }));\n  }\n};\n\nconst onChangeState = () => {\n  ctx.onfetch = onFetch;\n};\n\nctx.addEventListener('install', (event) => {\n  log('installing');\n  event.waitUntil(ctx.skipWaiting().then(() => log('skipped waiting'))); // Activate worker immediately\n});\n\nctx.addEventListener('activate', (event) => {\n  log('activating', ctx);\n  event.waitUntil(ctx.caches.delete(CACHE_ASSETS_NAME).then(() => log('cleared assets cache')));\n  event.waitUntil(ctx.clients.claim().then(() => log('claimed clients')));\n});\n\n// ctx.onerror = (error) => {\n//   log.error('error:', error);\n// };\n\n// ctx.onunhandledrejection = (error) => {\n//   log.error('onunhandledrejection:', error);\n// };\n\nctx.onoffline = ctx.ononline = onChangeState;\n\nonChangeState();\n"],"names":["Modes","DEBUG","ctx","MOUNT_CLASS_TO","USER_AGENT","IS_SAFARI","IS_FIREFOX","IS_SERVICE_WORKER","IS_WEB_WORKER","IS_WORKER","getWindowClients","postMessage","listener","args","err","notifyServiceWorker","all","listeners","notifyWorker","noop","_logTimer","dT","LogTypes","LOG_LEVELS","IS_WEBKIT","STYLES_SUPPORTED","LOGGER_STYLES","methods","logger","prefix","type","ignoreDebugReset","style","originalPrefix","originalStyle","log","method","logType","newPrefix","level","acc","v","prefixCache","_type","prefix2","pause","ms","resolve","CACHE_ASSETS_NAME","isCorrectResponse","response","timeoutRace","promise","requestCache","event","cache","file","headers","url","readBlobAs","blob","reader","e","readBlobAsArrayBuffer","readBlobAsUint8Array","buffer","deferredHelper","callback","value","deferredPromise","reject","deferred","_resolve","_reject","bytesFromHex","hexString","len","bytes","start","bytesCmp","bytes1","bytes2","i","readLengthField","buf","offset","length","size","byte","parseDecoderSpecificInfo","lenSz","parseDecoderConfigDescriptor","parseES_Descriptor","dv","flags","streamDependenceFlag","URL_Flag","URLlength","BROKEN_DSCI","FIXED_ESDS","ESDS","MP4A","findUint8ArrayBack","needle","found","j","fixMp4ForChromium","u8","pos","esdsOffset","esdsSize","mp4aOffset","esds","parsed","tryPatchMp4","debounce","fn","shouldRunFirst","shouldRunLast","waitingTimeout","waitingPromise","hadNewCall","invoke","result","_waitingTimeout","blobSafeMimeType","mimeType","blobConstruct","blobParts","safeMimeType","MemoryWriter","saveFileCallback","part","endOffset","newBytes","saveToStorage","parts","CACHED_ERRORS","makeError","_CacheStorageController","dbName","entryName","fileName","rejected","timeout","res","fileSize","enabled","clearWrite","storage","CacheStorageController","delay","deferredPromises","cacheStorage","CHUNK_TTL","CHUNK_CACHED_TIME_HEADER","clearOldChunks","requests","filtered","timestamp","request","match","promises","id","mtprotoMessagePort","getMtprotoMessagePort","messagePort","taskId","streams","Stream","info","STREAM_CHUNK_UPPER_LIMIT","STREAM_CHUNK_MIDDLE_LIMIT","alignedOffset","limit","fromPreload","payload","uploadFile","serviceMessagePort","bytesPromise","key","error","end","alignOffset","range","possibleResponse","responseForSafariFirstRange","alignLimit","ab","onStreamFetch","params","search","parseRange","stream","SMALLEST_CHUNK_LIMIT","header","chunks","ranges","base","DATABASE_STATE","NOTIFICATION_ICON_PATH","NOTIFICATION_BADGE_PATH","deepEqual","x","y","ignoreKeys","ignoreSet","okok","obj","ok","tx","safeAssign","object","fromObject","_IDB","db","createNew","createIndexes","os","store","indexNames","indexName","index","createObjectStore","finished","calledNew","transaction","target","instance","preserve","IDB","IDBStorage","storeName","isArray","objectStore","idx","mode","perf","onError","onComplete","results","r","waitForTransactionComplete","callbackResult","left","onRequestFinished","defaultBaseUrl","PING_PUSH_TIMEOUT","lastPingTime","localNotificationsAvailable","SomethingGetter","defaults","cached","getter","muteUntil","settings","lang","nowTime","userInvisibleIsSupported","notificationPromise","fireNotification","notification","action","data","clientList","pendingNotification","client","onCloseNotification","notifications","removeFromNotifications","closeAllNotifications","tag","title","body","peerId","messageKey","ignoreMessages","actions","notificationOptions","onPing","source","onShownNotification","time","_time","tabId","indexOfAndSplice","array","item","EventListenerBase","reuseResults","name","options","_a","listenerObject","l","collectResults","arr","USE_LOCKS","SuperMessagePort","logSuffix","task","previousResolve","ret","pingResolve","newEvent","innerTask","resultTaskPayload","resultTask","ackTask","isPromise","port","lock","port2","portTasks","tasks","batchTask","ports","transfer","withAck","_void","interval","ServiceMessagePort","listenMessagePort","onConnect","onDisconnect","attachPort","listenPort","sendPort","downloadMap","DOWNLOAD_ERROR","DOWNLOAD_TEST","events","strategy","controller","readable","_controller","reason","chunk","handleDownload","onDownloadFetch","cancelAllDownloads","parseFormData","formData","processShareEvent","clientId","checkWindowClientForDeferredShare","windowClient","onShareFetch","_mtprotoMessagePort","sendMessagePort","channel","sendMessagePortIfNeeded","connectedWindows","onWindowConnected","onDownloadClosedWindows","windowClients","onFetch","scope","_params","onChangeState"],"mappings":"AAaA,MAAMA,EAAQ,CACZ,KAAM,SAAS,OAAO,QAAQ,QAAQ,EAAI,EAC1C,MAAO,SAAS,OAAO,QAAQ,SAAS,EAAI,EAC5C,KAAM,GACN,IAAK,GACL,gBAAiB,GACjB,UAAW,YACX,eAAgB,SAAS,OAAO,QAAQ,kBAAkB,EAAI,EAC9D,mBAAoB,EACtB,GAGmBA,EAAM,KAAO,SAAS,OAAO,QAAQ,QAAQ,EAAI,KAEhEA,EAAM,mBAAqB,IAK5BA,EAAM,qBACPA,EAAM,KAAO,IAGZA,EAAM,OACPA,EAAM,UAAY,SC5BP,MAAAC,GAAoBD,EAAM,MACjCE,GAAW,OAAO,OAAY,IAAc,OAAS,KAC9CC,GAAqDD,GCX5DA,EAAM,OAAO,OAAY,IAAc,OAAS,KCQzCE,EAAa,UAAY,UAAU,UAAY,KACpC,UAAU,UAAU,OAAO,uBAAuB,EAChD,UAAU,UAAU,YAAc,EAAA,QAAQ,SAAS,GAE5C,IAAM,CACjC,GAAA,CACF,MAAO,CAAC,UAAU,UAAU,MAAM,gCAAgC,EAAE,CAAC,OAC1D,CACb,CACF,GAAG,EAOU,MAAAC,GAAe,WAAYH,GAAQ,CAAC,EAAEE,IAAe,yBAAyB,KAAKA,CAAU,GAAQA,EAAW,MAAM,QAAQ,GAAK,CAACA,EAAW,MAAM,QAAQ,IAC7JE,GAAa,UAAU,UAAU,cAAc,QAAQ,SAAS,EAAI,IAIvD,UAAU,iBAAmB,QAAa,UAAU,eAAiB,IAAM,UAAU,UAAU,OAAO,gHAAgH,GAAK,GCtB9O,MAAMC,EAAoB,OAAO,yBAA6B,KAAe,gBAAgB,yBACvFC,EAAgB,OAAO,kBAAsB,KAAe,gBAAgB,mBAAqB,CAACD,EAClGE,GAAYD,GAAiBD,EAE7BG,GAAmB,IACtB,KACP,QACA,SAAS,CAAC,oBAAqB,GAAO,KAAM,SAAS,EAKlDC,GAAc,CAACC,KAAwDC,IAAgB,CACvF,GAAA,CAEOD,EAAA,YAAY,GAAGC,CAAI,QACtBC,EAAK,CACH,QAAA,MAAM,8BAA+BA,EAAKD,CAAI,CACxD,CACF,EAEME,GAAsB,CAACC,KAAiBH,IAAgB,CAC3CH,GAAA,EAAE,KAAMO,GAAc,CACjCA,EAAU,QAKdA,EAAU,MAAMD,EAAM,EAAI,EAAE,EAAE,QAASJ,GAAa,CACtCD,GAAAC,EAAU,GAAGC,CAAI,CAAA,CAC9B,CAAA,CACF,CACH,EAEMK,GAAe,IAAIL,IAAgB,CAC3BF,GAAA,KAA2C,GAAGE,CAAI,CAChE,EAEMM,GAAO,IAAM,CAAC,EAESZ,GAAoBQ,GAAoB,KAAK,KAAM,EAAK,EAC5DR,GAAoBQ,GAAoB,KAAK,KAAM,EAAI,EChDhF,MAAMK,GAAY,KAAK,MACvB,SAAwBC,IAAK,CACpB,MAAA,MAAQ,KAAK,IAAI,EAAID,IAAa,KAAM,QAAQ,CAAC,EAAI,GAC9D,CCQY,IAAAE,GAAAA,IACVA,EAAAA,EAAA,KAAO,CAAP,EAAA,OACAA,EAAAA,EAAA,MAAQ,CAAR,EAAA,QACAA,EAAAA,EAAA,KAAO,CAAP,EAAA,OACAA,EAAAA,EAAA,IAAM,CAAN,EAAA,MACAA,EAAAA,EAAA,MAAQ,CAAR,EAAA,QALUA,IAAAA,GAAA,CAAA,CAAA,EAQL,MAAMC,GAAa,CAAC,EAAe,EAAgB,EAAe,EAAc,GAEjFC,GAAYnB,IAAaC,GAiBzBmB,GAAmB,CAACD,GAabE,EAAgB,CAC3B,MAAO,UACP,OAAQ,UACR,IAAK,UACL,WAAY,UACZ,MAAO,UACP,QAAS,UACT,OAAQ,UAER,GAAI,CACF,MAAO,WACP,IAAK,WACL,MAAO,WACP,OAAQ,WACR,KAAM,WACN,QAAS,WACT,KAAM,WACN,MAAO,UACT,EAEA,GAAI,CACF,MAAO,WACP,IAAK,WACL,MAAO,WACP,OAAQ,WACR,KAAM,WACN,QAAS,WACT,KAAM,WACN,MAAO,UACT,CACF,EAmBMC,GAA0I,CAC9I,CAAC,QAAS,CAAc,EACxB,CAAC,OAAQ,CAAY,EACrB,CAAC,OAAQ,CAAa,EACtB,CAAC,QAAS,CAAc,EACxB,CAAC,SAAU,CAAc,EACzB,CAAC,QAAS,CAAY,EACtB,CAAC,QAAS,CAAY,EACtB,CAAC,iBAAkB,CAAY,EAC/B,CAAC,WAAY,CAAY,CAE3B,EAEgB,SAAAC,EAAOC,EAAgBC,EAAiB,EAA+CC,EAAmB,GAAOC,EAAQ,GAAY,CAC/I,IAAAC,EACD,CAAChC,IAAS,CAAC8B,IACLD,EAAA,GAGLL,GAEOO,IACNzB,EAAmByB,EAAQN,EAAc,GAAG,OACvClB,IAAewB,EAAQN,EAAc,GAAG,OAHxCM,EAAA,GAMV,MAAME,EAAgBF,EACnBA,EAAOA,EAAQ,MAAMA,CAAK,KAChBA,EAAA,KAIP,MAAAG,EAAc,YAAYtB,EAAa,CACpC,OAAAiB,EAAO,GAAgB,QAAQ,IAAIE,EAAOX,KAAMQ,EAAuC,GAAGhB,CAAI,CAAA,EAGvGc,GAAQ,QAAQ,CAAC,CAACS,EAAQC,CAAO,IAAM,CACjCF,EAAAC,CAAM,EAAI,YAAYvB,EAAa,CAC9B,OAAAiB,EAAOO,GAAW,QAAQD,CAAM,EAAEJ,EAAOX,KAAMQ,EAAuC,GAAGhB,CAAI,CAAA,CACtG,CACD,EAEGsB,EAAA,UAAY,SAASG,EAAmB,CACzBL,EAAAK,EACjBT,EAAS,IAAMS,EAAY,GAAA,EAG7BH,EAAI,UAAUN,CAAM,EAEhBM,EAAA,SAAW,SAASI,EAA0B,CAChDT,EAAOP,GAAW,MAAM,EAAGgB,EAAQ,CAAC,EAAE,OAAO,CAACC,EAAKC,IAAMD,EAAMC,EAAG,CAAC,CAAA,EAGrE,MAAMC,EAA0C,CAAA,EAChD,OAAAP,EAAI,WAAa,SAASN,EAAgBc,EAAQb,EAAM,CAC/C,OAAAY,EAAAE,KAAAF,EAAAE,GAAwBhB,EAE7B,GAAGK,CAAc,KAAKR,IAAoBS,EAAgBR,EAAc,MAAQ,EAAE,IAAIG,CAAM,GAE5Fc,EACAZ,EAEAG,CAAA,EAEF,EAGKC,CACT,CCxKA,SAAwBU,GAAMC,EAAY,CACjC,OAAA,IAAI,QAAeC,GAAY,CACpC,WAAWA,EAASD,CAAE,CAAA,CACvB,CACH,CCIA,MAAM5C,GAAM,KACC8C,GAAoB,eAEjC,SAASC,EAAkBC,EAAoB,CACtC,OAAAA,EAAS,IAAMA,EAAS,SAAW,GAC5C,CAEA,SAASC,GAAoCC,EAAY,CACvD,OAAO,QAAQ,KAAK,CAClBA,EACAP,GAAM,GAAK,EAAE,KAAK,IAAM,QAAQ,QAAQ,CAAA,CACzC,CACH,CAEA,eAAsBQ,GAAaC,EAAmB,CAChD,GAAA,CAEF,MAAMC,EAAQ,MAAMJ,GAAYjD,GAAI,OAAO,KAAK8C,EAAiB,CAAC,EAC5DQ,EAAO,MAAML,GAAYI,EAAM,MAAMD,EAAM,QAAS,CAAC,WAAY,EAAI,CAAC,CAAC,EAE1E,GAAAE,GAAQP,EAAkBO,CAAI,EACxB,OAAAA,EAGH,MAAAC,EAAuB,CAAC,KAAQ,KACtC,IAAIP,EAAW,MAAM,MAAMI,EAAM,QAAS,CAAC,QAAAG,EAAQ,EAChD,GAAAR,EAAkBC,CAAQ,EAC3BK,EAAM,IAAID,EAAM,QAASJ,EAAS,OAAO,UACjCA,EAAS,SAAW,IAAK,CACjC,MAAMQ,EAAMJ,EAAM,QAAQ,IAAI,QAAQ,QAAS,EAAE,EAAI,KAAO,KAAK,OAAO,EAAI,IAAS,GACrFJ,EAAW,MAAM,MAAMQ,EAAK,CAAC,QAAAD,CAAQ,CAAA,EAClCR,EAAkBC,CAAQ,GAC3BK,EAAM,IAAID,EAAM,QAASJ,EAAS,OAAO,CAE7C,CAEO,OAAAA,OACI,CACJ,OAAA,MAAMI,EAAM,OAAO,CAC5B,CACF,CCpCwB,SAAAK,GAAWC,EAAYxB,EAA4E,CAElH,OAAA,IAAI,QAAcW,GAAY,CAC7B,MAAAc,EAAS,IAAI,WACZA,EAAA,iBAAiB,UAAYC,GAAM,CAEhCf,EAAAe,EAAE,OAAO,MAAM,CAAA,CACxB,EACMD,EAAAzB,CAAM,EAAEwB,CAAI,CAAA,CACpB,CACH,CCdA,SAAwBG,GAAsBH,EAAY,CACjD,OAAAD,GAAWC,EAAM,mBAAmB,CAC7C,CCFA,SAAwBI,GAAqBJ,EAAY,CAChD,OAAAG,GAAsBH,CAAI,EAAE,KAAMK,GAAW,IAAI,WAAWA,CAAM,CAAC,CAC5E,CCVA,SAAwB9C,IAAO,CAAC,CC2BhC,MAAM+C,GAAiB,CACrB,YAAa,GACb,WAAY,GAEZ,OAAQ,IAAM,CAAC,EACf,UAAW,YAAYrD,EAAa,CAClC,KAAK,WAAaA,EAClB,KAAK,WAAW,QAASsD,GAAkBA,EAAS,GAAGtD,CAAI,CAAC,CAC9D,EAEA,kBAAmB,SAASsD,EAAoC,CAC3D,KAAK,YACGA,EAAA,GAAG,KAAK,UAAU,GAG5B,KAAK,YAAL,KAAK,UAAc,CAAC,IAAG,KAAKA,CAAQ,CACvC,EAEA,QAAS,SAASC,EAAO,CACpB,KAAK,aAAe,KAAK,aAE5B,KAAK,YAAc,GACnB,KAAK,SAASA,CAAK,EACnB,KAAK,SAAS,EAChB,EAEA,OAAQ,YAAYvD,EAAM,CACrB,KAAK,YAAc,KAAK,cAE3B,KAAK,WAAa,GACb,KAAA,QAAQ,GAAGA,CAAI,EACpB,KAAK,SAAS,EAChB,EAEA,SAAU,UAAW,CACnB,KAAK,OAAS,KAAK,UAAY,KAAK,WAAa,KAC9C,KAAK,YAAW,KAAK,UAAU,OAAS,GAExC,KAAK,SACN,KAAK,OAASM,GAElB,CACF,EAEA,SAAwBkD,GAAqB,CAC3C,IAAItB,EAA6BuB,EACjC,MAAMC,EAAkC,IAAI,QAAW,CAACC,EAAUC,IAAY,CAC5E1B,EAAUyB,EAAUF,EAASG,CAAA,CAC9B,EAEM,cAAA,OAAOF,EAAUL,EAAc,EACtCK,EAAS,SAAWxB,EACpBwB,EAAS,QAAUD,EAEZC,CACT,CAEC,KAAa,gBAAkBF,ECpFhC,SAAwBK,GAAaC,EAAmB,CACtD,MAAMC,EAAMD,EAAU,OAChBE,EAAQ,IAAI,WAAW,KAAK,KAAKD,EAAM,CAAC,CAAC,EAC/C,IAAIE,EAAQ,EAETF,EAAM,IACPC,EAAMC,GAAO,EAAI,SAASH,EAAU,OAAO,CAAC,EAAG,EAAE,GAGnD,QAAQ,EAAIG,EAAO,EAAIF,EAAK,GAAK,EACzBC,EAAAC,GAAO,EAAI,SAASH,EAAU,OAAO,EAAG,CAAC,EAAG,EAAE,EAG/C,OAAAE,CACT,CCdwB,SAAAE,GAASC,EAA+BC,EAA+B,CAC7F,MAAML,EAAMI,EAAO,OAChB,GAAAJ,IAAQK,EAAO,OACT,MAAA,GAGT,QAAQC,EAAI,EAAGA,EAAIN,EAAK,EAAEM,EACxB,GAAGF,EAAOE,CAAC,IAAMD,EAAOC,CAAC,EAChB,MAAA,GAIJ,MAAA,EACT,CCVA,SAASC,EAAgBC,EAAiBC,EAAgB,CACxD,IAAIC,EAAS,EACTC,EAAO,EAEX,QAAQ,EAAI,EAAG,EAAI,EAAG,IAAK,CACnB,MAAAC,EAAOJ,EAAIC,EAAS,CAAC,EAGvB,GAFMC,GAAAA,GAAU,IAAME,EAAO,KACjCD,IACI,EAAAC,EAAO,KACT,KAEJ,CAEO,MAAA,CAACD,EAAMD,CAAM,CACtB,CAEA,SAASG,GAAyBL,EAAiB,CAC9C,GAAAA,EAAI,CAAC,IAAM,EACN,MAAA,IAAI,MAAM,iCAAiC,EAGnD,KAAM,CAACM,EAAOd,CAAG,EAAIO,EAAgBC,EAAK,CAAC,EACrCC,EAAS,EAAIK,EAEnB,OAAON,EAAI,SAASC,EAAQA,EAAST,CAAG,CAC1C,CAEA,SAASe,GAA6BP,EAAiB,CAClD,GAAAA,EAAI,CAAC,IAAM,EACN,MAAA,IAAI,MAAM,qCAAqC,EAGvD,KAAM,CAACM,EAAOd,CAAG,EAAIO,EAAgBC,EAAK,CAAC,EAC3C,IAAIC,EAAS,EAAIK,EAEP,OAAAL,GAAA,GAMkBI,GAAyBL,EAAI,SAASC,CAAM,CAAC,CAG3E,CAEA,SAASO,GAAmBR,EAAiB,CACxC,GAAAA,EAAI,CAAC,IAAM,EACN,MAAA,IAAI,MAAM,2BAA2B,EAGvC,MAAAS,EAAK,IAAI,SAAST,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC5D,CAACM,EAAOd,CAAG,EAAIO,EAAgBC,EAAK,CAAC,EAC3C,IAAIC,EAAS,EAAIK,EACPL,GAAA,EACJ,MAAAS,EAAQD,EAAG,SAASR,CAAM,EACtBA,GAAA,EAEV,MAAMU,EAAuBD,EAAQ,IAC/BE,EAAWF,EAAQ,GAKzB,GAHGC,IACSV,GAAA,GAETW,EAAU,CACL,MAAAC,EAAYd,EAAgBC,EAAKC,CAAM,EAC7CA,GAAU,EAAIY,EAAU,CAAC,EAAIA,EAAU,CAAC,CAC1C,CAIA,MAAO,CAAC,wBAFwBN,GAA6BP,EAAI,SAASC,CAAM,CAAC,CAElD,CACjC,CAYA,MAAMa,GAAc,CAAC,GAAM,GAAI,EAIzBC,EAAazB,GAAa,wDAAwD,EAClF0B,GAAO,IAAI,YAAY,EAAE,OAAO,MAAM,EACtCC,GAAO,IAAI,YAAY,EAAE,OAAO,MAAM,EAE5C,SAASC,GAAmBlB,EAAiBmB,EAAoBzB,EAAQM,EAAI,OAAQ,CACnF,QAAQF,EAAIJ,EAAQyB,EAAO,OAAQrB,GAAK,EAAGA,IAAK,CAC9C,IAAIsB,EAAQ,GACZ,QAAQC,EAAI,EAAGA,EAAIF,EAAO,OAAQE,IAChC,GAAGrB,EAAIF,EAAIuB,CAAC,IAAMF,EAAOE,CAAC,EAAG,CACnBD,EAAA,GACR,KACF,CAEC,GAAAA,EAAc,OAAAtB,CACnB,CAEO,MAAA,EACT,CAEA,SAASwB,GAAkBC,EAAgB,CACnC,MAAAd,EAAK,IAAI,SAASc,EAAG,OAAQA,EAAG,WAAYA,EAAG,UAAU,EAG/D,IAAIC,EAAMD,EAAG,OACTH,EAAQ,KACZ,OAAY,CACV,MAAMK,EAAaP,GAAmBK,EAAIP,GAAMQ,CAAG,EACnD,GAAGC,IAAe,GAAI,MAChBD,EAAAC,EAGN,MAAMC,EAAWjB,EAAG,UAAUgB,EAAa,CAAC,EAC5C,GAAGC,EAAW,GAAKD,EAAaC,EAAWH,EAAG,OAE5C,SAIF,MAAMI,EAAaT,GAAmBK,EAAIN,GAAMQ,CAAU,EACvDE,IAAe,IAAMF,EAAaE,EAAa,MAElDP,EAAQ,CAAC,OAAQK,EAAa,EAAG,KAAMC,EAAW,IACpD,CAEA,GAAG,CAACN,EAAa,MAAA,IAAI,MAAM,eAAe,EAEpC,MAAAQ,EAAOL,EAAG,SAASH,EAAM,OAAQA,EAAM,OAASA,EAAM,IAAI,EAE1DS,EAASrB,GAAmBoB,CAAI,EACtC,GAAG,CAACC,EAAc,MAAA,IAAI,MAAM,cAAc,EAC1C,GAAG,CAAClC,GAASkC,EAAO,wBAAyBf,EAAW,EAChD,MAAA,IAAI,MAAM,mBAAmB,EAGlC,GAAAM,EAAM,KAAOL,EAAW,OACnB,MAAA,IAAI,MAAM,2CAA2CA,EAAW,MAAM,SAASK,EAAM,IAAI,GAAG,EAGjGG,EAAA,IAAIR,EAAYK,EAAM,MAAM,CACjC,CAEA,SAAwBU,GAAYP,EAAgB,CAO9C,GAAA,CACF,OAAAD,GAAkBC,CAAE,EACb,QACE,CACF,MAAA,EACT,CACF,CCzJA,SAAwBQ,GACtBC,EACAtE,EACAuE,EAAiB,GACjBC,EAAgB,GACO,CACnB,IAAAC,EACAC,EAAiDzE,EAAgCuB,EACjFmD,EAAa,GAEX,MAAAC,EAAU7G,GAAwB,CAChC,MAAA2D,EAAWzB,EAAS0B,EAAUH,EAChC,GAAA,CACF,MAAMqD,EAASP,EAAG,MAAM,KAAMvG,CAAI,EAClC2D,EAASmD,CAAM,QACT7G,EAAK,CACH,QAAA,MAAM,iBAAkBA,CAAG,EAEnC2D,EAAQ3D,CAAG,CACb,CAAA,EAGIqG,EAAW,IAAItG,IAAwB,CACvC2G,IAAiCA,EAAA,IAAI,QAAQ,CAAChD,EAAUC,KAAa1B,EAAUyB,EAAUF,EAASG,EAAQ,GAE3G8C,GACD,aAAaA,CAAc,EACdE,EAAA,GACNnD,IACUkD,EAAA,IAAI,QAAQ,CAAChD,EAAUC,KAAa1B,EAAUyB,EAAUF,EAASG,EAAQ,GAClF4C,IACRK,EAAO7G,CAAI,EACE4G,EAAA,IAGT,MAAAG,EAAkB1H,EAAI,WAAW,IAAM,CAExCoH,IAAkB,CAACD,GAAkBI,IACtCC,EAAO7G,CAAI,EAIV0G,IAAmBK,IACHL,EAAAC,EAAiBzE,EAAUuB,EAAS,OACxCmD,EAAA,KAEd3E,CAAE,EAEY,OAAAyE,EAAAK,EACjBJ,EAAe,MAAMrG,EAAI,EAClBqG,CAAA,EAGTL,OAAAA,EAAS,aAAe,IAAM,CACzBI,IACDrH,EAAI,aAAaqH,CAAc,EACxBjD,IACUiD,EAAAC,EAAiBzE,EAAUuB,EAAS,OACxCmD,EAAA,GACf,EAGFN,EAAS,YAAc,IAAM,CAAC,CAACI,EAExBJ,CACT,CCjEA,SAAwBU,GAAiBC,EAAkB,CACtD,MAAA,CACD,aACA,YACA,YACA,gBACA,aACA,YACA,aACA,YACA,YACA,aACA,kBACA,YACA,aACA,YACA,YACA,mBACA,iBACA,EAAA,QAAQA,CAAQ,IAAM,GACf,2BAGFA,CACT,CCvBwB,SAAAC,GAA6CC,EAAyBF,EAAmB,GAAU,CACrH,MAAM,QAAQE,CAAS,IACzBA,EAAY,CAACA,CAAS,GAGlB,MAAAC,EAAeJ,GAAiBC,CAAQ,EAEvC,OADM,IAAI,KAAKE,EAAW,CAAC,KAAMC,EAAa,CAEvD,CCZA,MAAqBC,EAAqC,CAGxD,YACUJ,EACAvC,EACA4C,EACR,CAHQ,KAAA,SAAAL,EACA,KAAA,KAAAvC,EACA,KAAA,iBAAA4C,EAEH,KAAA,MAAQ,IAAI,WAAW5C,CAAI,CAClC,CAEA,MAAa,MAAM6C,EAAkB/C,EAAgB,CAE7C,MAAAgD,EAAYhD,EAAS+C,EAAK,WAC7B,GAAAC,EAAY,KAAK,MAAM,WAAY,CAC9B,MAAAC,EAAW,IAAI,WAAWD,CAAS,EAChCC,EAAA,IAAI,KAAK,MAAO,CAAC,EAC1B,KAAK,MAAQA,CACf,CAEK,KAAA,MAAM,IAAIF,EAAM/C,CAAM,CAC7B,CAEO,UAAW,CACX,KAAA,MAAQ,IAAI,UACnB,CAEO,KAAKE,EAAc,CACxB,KAAK,MAAQ,KAAK,MAAM,MAAM,EAAGA,CAAI,CACvC,CAEO,SAASgD,EAAgB,GAAM,CACpC,MAAM3E,EAAOmE,GAAc,KAAK,MAAO,KAAK,QAAQ,EAEjD,OAAAQ,GAAiB,KAAK,kBACvB,KAAK,iBAAiB3E,CAAI,EAGrBA,CACT,CAEO,UAAW,CAChB,OAAO,KAAK,KACd,CAEO,aAAa4E,EAAmB,CACrC,KAAK,MAAQA,CACf,CACF,CCzDA,MAAMC,EAAqD,CAAA,EAC3D,SAAwBC,EAAU5G,EAAqB,CAC9C,OAAA2G,EAAA3G,KAAA2G,EAAA3G,GAAwB,CAC7B,KAAAA,CAAA,EAEJ,CCWA,MAAqB6G,EAArB,MAAqBA,CAA8C,CAQjE,YAAoBC,EAA4B,CAA5B,KAAA,OAAAA,EAJpB,KAAQ,WAAa,GAKhB5I,EAAM,OACP,KAAK,QAAU,SAGd2I,EAAuB,SAAS,SACjC,KAAK,WAAaA,EAAuB,SAAS,CAAC,EAAE,YAGvD,KAAK,aAAa,EACKA,EAAA,SAAS,KAAK,IAAI,CAC3C,CAEQ,cAA+B,CACrC,OAAO,KAAK,gBAAkB,KAAK,cAAgB,OAAO,KAAK,KAAK,MAAM,EAC5E,CAEO,OAAOE,EAAmB,CACxB,OAAA,KAAK,iBAAkBtF,GAAUA,EAAM,OAAO,IAAMsF,CAAS,CAAC,CACvE,CAEO,WAAY,CACV,OAAA,OAAO,OAAO,KAAK,MAAM,CAClC,CAEO,IAAIA,EAAmB,CACrB,OAAA,KAAK,iBAAkBtF,GAAUA,EAAM,MAAM,IAAMsF,CAAS,CAAC,CACtE,CAEO,KAAKA,EAAmB3F,EAAoB,CAE1C,OAAA,KAAK,iBAAkBK,GAAUA,EAAM,IAAI,IAAMsF,EAAW3F,CAAQ,CAAC,CAC9E,CAEO,QAAQ4F,EAAkB1G,EAAmC,OAAsB,CAOxF,OAAO,KAAK,IAAI0G,CAAQ,EAAE,KAAM5F,GAAa,CAC3C,GAAG,CAACA,EAEF,MAAMwF,EAAU,gBAAgB,EAO3B,OAJSxF,EAASd,CAAM,GAIxB,CACR,CACH,CAEO,SAAS0G,EAAkBlF,EAAyB,CAEpDA,aAAgB,OACnBA,EAAOmE,GAAcnE,CAAI,GAGrB,MAAAV,EAAW,IAAI,SAASU,EAAM,CAClC,QAAS,CACP,iBAAkB,GAAKA,EAAK,IAC9B,CAAA,CACD,EAED,OAAO,KAAK,KAAKkF,EAAU5F,CAAQ,EAAE,KAAK,IAAMU,CAAY,CAC9D,CAEO,iBAAoBO,EAAwC,CAC9D,OAAC,KAAK,WAIF,IAAI,QAAW,MAAMpB,EAASuB,IAAW,CAC9C,IAAIyE,EAAW,GACT,MAAAC,EAAU,WAAW,IAAM,CACxB1E,IAEIyE,EAAA,IACV,IAAI,EAEH,GAAA,CACI,MAAAxF,EAAQ,MAAM,KAAK,eACzB,GAAG,CAACA,EACF,WAAK,WAAa,GAClB,KAAK,cAAgB,OACf,YAGF,MAAA0F,EAAM,MAAM9E,EAASZ,CAAK,EAE7B,GAAAwF,EAAU,OACbhG,EAAQkG,CAAG,QACLnI,EAAK,CACXwD,EAAOxD,CAAG,CACZ,CAEA,aAAakI,CAAO,CAAA,CACrB,EA5BQ,QAAQ,OAAON,EAAU,iBAAiB,CAAC,CA6BtD,CAEO,eAAeI,EAAkBI,EAAkBpB,EAAkB,CACnE,MAAA,CACL,SAAUzD,EAAsB,EAChC,UAAW,IACM,IAAI6D,GAAaJ,EAAUoB,EAAWtF,GAC5C,KAAK,SAASkF,EAAUlF,CAAI,EAAE,MAAM,IAAMA,CAAI,CACtD,CAGH,CAEJ,CAEA,OAAc,cAAcuF,EAAkBC,EAAqB,CACjE,OAAO,QAAQ,IAAI,KAAK,SAAS,IAAKC,GAAY,CAGhD,GAFAA,EAAQ,WAAaF,EAElB,EAACC,GAID,CAACD,EACF,OAAOE,EAAQ,WAElB,CAAA,CAAC,CACJ,CACF,EAxIEV,EAAe,SAAqC,GADtD,IAAqBW,EAArBX,EChBA,SAAwBK,GAAQO,EAAkC,CACzD,OAAA,IAAI,QAAUxG,GAAY,CAC/B,WAAW,IAAM,CACPA,EAAA,IAAI,SAAS,GAAI,CACvB,OAAQ,IACR,WAAY,oBACb,CAAA,CAAC,GACDwG,CAAK,CAAA,CACR,CACJ,CCSA,MAAMC,MAA+F,IAC/FC,EAAe,IAAIH,EAAuB,oBAAoB,EAC9DI,GAAY,MACZC,GAA2B,cAI3BC,GAAiB,IACdH,EAAa,iBAAkBlG,GAC7BA,EAAM,KAAA,EAAO,KAAMsG,GAAa,CAC/B,MAAAC,MAAuC,IACvCC,EAAY,KAAK,IAAI,EAAI,IAAO,EACtC,UAAUC,KAAWH,EAAU,CAC7B,MAAMI,EAAQD,EAAQ,IAAI,MAAM,YAAY,EACzCC,GAAS,CAACH,EAAS,IAAIG,EAAM,CAAC,CAAC,GAChCH,EAAS,IAAIG,EAAM,CAAC,EAAGD,CAAO,CAElC,CAEA,MAAME,EAA2B,CAAA,EACjC,SAAU,CAACC,EAAIH,CAAO,IAAKF,EAAU,CACnC,MAAM1G,EAAUG,EAAM,MAAMyG,CAAO,EAAE,KAAM9G,GAAa,CACtD,GAAI,CAACA,EAAS,QAAQ,IAAIyG,EAAwB,EAAID,IAAcK,EAClE,OAAA5H,EAAI,4BAA6BgI,CAAE,EAC5B5G,EAAM,OAAOyG,EAAS,CAAC,aAAc,GAAM,WAAY,GAAK,CACrE,CACD,EAEDE,EAAS,KAAK9G,CAAO,CACvB,CAEO,OAAA,QAAQ,IAAI8G,CAAQ,CAAA,CAC5B,CACF,EAGH,YAAYN,GAAgB,IAAM,EAClC,YAAY,IAAM,CAChB,MAAMQ,EAAqBC,KAC3B,SAAU,CAACC,EAAaJ,CAAQ,IAAKV,EACnC,GAAGc,IAAgBF,EAInB,WAAUG,KAAUL,EACFA,EAASK,CAAM,EACvB,OAAO,EAGjBf,EAAiB,OAAOc,CAAW,EAEvC,EAAG,IAAK,EAIR,MAAME,MAAqC,IAC3C,MAAMC,CAAO,CAOX,YAAoBC,EAAuB,CAAvB,KAAA,KAAAA,EAHZ,KAAA,kBAAiC,IAYzC,KAAQ,QAAU,IAAM,CACdF,EAAA,OAAO,KAAK,EAAE,CAAA,EATjB,KAAA,GAAKC,EAAO,MAAMC,CAAI,EACnBF,EAAA,IAAI,KAAK,GAAI,IAAI,EAGzB,KAAK,UAAYE,EAAK,KAAQ,GAAK,KAAO,KAAQC,GAA2BC,GAC7E,KAAK,iBAAmBzD,GAAS,KAAK,QAAS,KAAQ,GAAO,EAAI,CACpE,CAMA,MAAc,0BAA0B0D,EAAuBC,EAAeC,EAAc,GAAO,CACjG,MAAMC,EAA6C,CACjD,MAAO,KAAK,GACZ,KAAM,KAAK,KAAK,KAChB,OAAQH,EACR,MAAAC,CAAA,EAGIP,EAAS,KAAK,UAAUS,CAAO,EAE/BZ,EAAqBC,KACvB,IAAAH,EAAWV,EAAiB,IAAIY,CAAkB,EAClDF,GACFV,EAAiB,IAAIY,EAAoBF,EAAW,CAAE,CAAA,EAGpD,IAAA3F,EAAW2F,EAASK,CAAM,EAC9B,GAAGhG,EACD,OAAOA,EAAS,KAAM0G,GAAeA,EAAW,KAAK,EAGlD,KAAA,cAAc,IAAIJ,CAAa,EAEzBtG,EAAA2F,EAASK,CAAM,EAAIlG,EAAgB,EAE9C6G,EAAmB,OAAO,kBAAmBF,EAAS,OAAWZ,CAAkB,EAClF,KAAK7F,EAAS,QAAQ,KAAKA,CAAQ,EAAGA,EAAS,OAAO,KAAKA,CAAQ,CAAC,EAAE,QAAQ,IAAM,CAChF2F,EAASK,CAAM,IAAMhG,IACtB,OAAO2F,EAASK,CAAM,EAElB,OAAO,KAAKL,CAAQ,EAAE,QACxBV,EAAiB,OAAOY,CAAkB,EAE9C,CACD,EAED,MAAMe,EAAe5G,EAAS,KAAM0G,GAAeA,EAAW,KAAK,EAG5D,YAAA,iBAAiBE,EAAcN,EAAeC,CAAK,EACxD,CAACC,GAAe,KAAK,cAAcF,EAAeA,EAAiB,KAAK,UAAY,EAAG,EAGlFM,CACT,CAEQ,yBAAyBN,EAAuBC,EAAeC,EAAuB,CAK5F,MAAMK,EAAM,KAAK,YAAYP,EAAeC,CAAK,EACjD,OAAOrB,EAAa,QAAQ2B,CAAG,EAAE,KAAMxH,GAC9BmH,EAAc,IAAI,WAAe/G,GAAqBJ,CAAI,EAC/DyH,GAAoB,CACnBA,EAAM,IAET,CACD,CACH,CAEQ,gBAAgBR,EAAuBC,EAAeC,EAAuB,CAe5E,OAdS,KAAK,yBAAyBF,EAAeC,EAAOC,CAAW,EAAE,KAAMlG,GAC9EA,GAAS,KAAK,0BAA0BgG,EAAeC,EAAOC,CAAW,CACjF,CAaH,CAEQ,iBAAiBxG,EAA+BsG,EAAuBC,EAAe,CACrF,OAAAvG,EAAS,KAAMM,GAAU,CAC9B,MAAMuG,EAAM,KAAK,YAAYP,EAAeC,CAAK,EAC3C5H,EAAW,IAAI,SAAS2B,EAAO,CACnC,QAAS,CACP,iBAAkB,GAAKA,EAAM,OAC7B,eAAgB,2BAChB,CAAC8E,EAAwB,EAAG,IAAM,KAAK,MAAQ,IAAO,EACxD,CAAA,CACD,EAEM,OAAAF,EAAa,KAAK2B,EAAKlI,CAAQ,CAAA,CACvC,CACH,CAEQ,aAAamC,EAAgB,CAChC,KAAK,cAAc,IAAIA,CAAM,IAI3B,KAAA,cAAc,IAAIA,CAAM,EAC7B,KAAK,gBAAgBA,EAAQ,KAAK,UAAW,EAAI,EACnD,CAEQ,cAAcA,EAAgBiG,EAAa,CAKjD,GAJGA,EAAM,KAAK,KAAK,OACjBA,EAAM,KAAK,KAAK,MAGf,CAACjG,EACF,KAAK,aAAakG,GAAYlG,EAAQ,KAAK,SAAS,CAAC,MAErD,MAAMA,EAASiG,EAAKjG,GAAU,KAAK,UACjC,KAAK,aAAaA,CAAM,CAG9B,CAEO,aAAamG,EAAoB,CACtC,KAAK,iBAAiB,EAEhB,MAAAC,EAAmBC,GAA4BF,EAAO,KAAK,KAAK,SAAU,KAAK,KAAK,IAAI,EAC9F,GAAGC,EACM,OAAAA,EAGL,GAAA,CAACpG,EAAQiG,CAAG,EAAIE,EAQd,MAAAV,EAAQQ,GAAOA,EAAM,KAAK,UAAYK,GAAWL,EAAMjG,EAAS,CAAC,EAAI,KAAK,UAC1EwF,EAAgBU,GAAYlG,EAAQyF,CAAK,EAE/C,OAAIQ,IACFA,EAAM,KAAK,IAAIjG,EAASyF,EAAO,KAAK,KAAK,KAAO,CAAC,GAG5C,KAAK,gBAAgBD,EAAeC,CAAK,EAAE,KAAMc,GAAO,EAI1DvG,IAAWwF,GAAiBS,IAAST,EAAgBC,KACtDc,EAAKA,EAAG,MAAMvG,EAASwF,EAAeS,EAAMT,EAAgB,CAAC,IAG5D,KAAK,iBAAmB,IAAQ,KAAK,iBAAmBA,IACtD3D,GAAY0E,CAAE,IACf,KAAK,eAAiBf,GAO1B,MAAMpH,EAAkC,CACtC,gBAAiB,QACjB,gBAAiB,SAAS4B,CAAM,IAAIA,EAASuG,EAAG,WAAa,CAAC,IAAI,KAAK,KAAK,MAAQ,GAAG,GACvF,iBAAkB,GAAGA,EAAG,UAAU,EAAA,EAGjC,OAAA,KAAK,KAAK,WACHnI,EAAA,cAAc,EAAI,KAAK,KAAK,UAK/B,IAAI,SAASmI,EAAI,CACtB,OAAQ,IACR,WAAY,kBACZ,QAAAnI,CAAA,CACD,CAAA,CAEF,CACH,CAEQ,YAAYoH,EAAuBC,EAAe,CACxD,OAAO,KAAK,GAAK,WAAaD,EAAgB,UAAYC,CAC5D,CAEO,kBAAmB,CACxB,KAAK,eAAiB,EACxB,CAEA,OAAc,IAAIJ,EAAuB,CAChC,OAAAF,EAAQ,IAAI,KAAK,MAAME,CAAI,CAAC,GAAK,IAAID,EAAOC,CAAI,CACzD,CAEA,OAAe,MAAMA,EAAuB,CAC1C,OAAQA,EAAK,SAAyD,EACxE,CACF,CAEwB,SAAAmB,GAAcvI,EAAmBwI,EAAgBC,EAAgB,CACvF,MAAMP,EAAQQ,GAAW1I,EAAM,QAAQ,QAAQ,IAAI,OAAO,CAAC,EACrDoH,EAAwB,KAAK,MAAM,mBAAmBoB,CAAM,CAAC,EAC7DG,EAASxB,EAAO,IAAIC,CAAI,EAE3BqB,IAAW,iBACZE,EAAO,iBAAiB,EAKpB3I,EAAA,YAAY,QAAQ,KAAK,CAC7B0F,GAAQ,GAAK,GAAI,EACjBiD,EAAO,aAAaT,CAAK,CAC1B,CAAA,CAAC,CACJ,CAEA,SAASE,GAA4BF,EAAoB1D,EAAkBvC,EAAwB,CACjG,OAAGiG,EAAM,CAAC,IAAM,GAAKA,EAAM,CAAC,IAAM,EACzB,IAAI,SAAS,IAAI,WAAW,CAAC,EAAE,OAAQ,CAC5C,OAAQ,IACR,WAAY,kBACZ,QAAS,CACP,gBAAiB,QACjB,gBAAiB,aAAajG,GAAQ,GAAG,GACzC,iBAAkB,IAClB,eAAgBuC,GAAY,WAC9B,CAAA,CACD,EAGI,IACT,CAMA,MAAM8C,GAA4B,IAAM,KAClCD,GAA2B,KAAO,KAClCuB,GAAuB,IAAM,EAEnC,SAASF,GAAWG,EAA6B,CAC/C,GAAG,CAACA,EAAe,MAAA,CAAC,EAAG,CAAC,EACxB,KAAM,CAAG,CAAAC,CAAM,EAAID,EAAO,MAAM,GAAG,EAC7BE,EAASD,EAAO,MAAM,IAAI,EAC1B,CAAC/G,EAAQiG,CAAG,EAAIe,EAAO,CAAC,EAAE,MAAM,GAAG,EAEzC,MAAO,CAAC,CAAChH,EAAQ,CAACiG,GAAO,CAAC,CAC5B,CAEA,SAASC,GAAYlG,EAAgBiH,EAAOJ,GAAsB,CAChE,OAAO7G,EAAUA,EAASiH,CAC5B,CAEA,SAASX,GAAWb,EAAe,CAC1B,MAAA,IAAK,KAAK,KAAK,KAAK,IAAIA,CAAK,EAAI,KAAK,IAAI,CAAC,CAAC,CACrD,CCjVA,MAAMyB,GAAmG,CACvG,KAAM,OACN,QAAS,EACT,OAAQ,CAAC,CACP,KAAM,SAAA,EACL,CACD,KAAM,aAAA,EACL,CACD,KAAM,OAAA,EACL,CACD,KAAM,OAAA,EACL,CACD,KAAM,SAAA,EAaL,CACD,KAAM,UAAA,CACP,CACH,ECrCaC,GAAyB,qCACzBC,GAA0B,4BCEf,SAAAC,GAAaC,EAAMC,EAAMC,EAAmC,CAClF,MAAMC,EAAYD,GAAc,IAAI,IAAIA,CAAU,EAC5CE,EAAQC,GAAa,OAAO,KAAKA,CAAG,EAAE,OAAQ5B,GAAQ4B,EAAI5B,CAAG,IAAM,MAAS,EAC5E6B,EAAKJ,EAAcG,GAAaD,EAAKC,CAAG,EAAE,OAAQ5B,GAAQ,CAAC0B,EAAU,IAAI1B,CAAU,CAAC,EAAI2B,EAC5FG,EAAK,OAAOP,EAEd,OAAOA,GAAKC,GAAKM,IAAO,UAAYA,IAD7B,OAAON,EAEZK,EAAGN,CAAC,EAAE,SAAWM,EAAGL,CAAC,EAAE,QACrBK,EAAGN,CAAC,EAAE,MAAOvB,GAAQsB,GAAWC,EAAUvB,CAAG,EAAIwB,EAAUxB,CAAG,EAAGyB,CAAU,CAAC,EAC3EF,IAAMC,CACb,CCbwB,SAAAO,GAAcC,EAAWC,EAAiB,CAChE,GAAGA,EACD,UAAUnI,KAAKmI,EACVA,EAAWnI,CAAC,IAAM,SAEZkI,EAAAlI,CAAC,EAAImI,EAAWnI,CAAC,GAKvB,OAAAkI,CACT,CC6BO,MAAME,EAAN,MAAMA,CAAI,CAUf,YAAYC,EAAmB,CAC7BJ,GAAW,KAAMI,CAAE,EAEhBvN,EAAM,OACP,KAAK,MAAQ,SAGf,KAAK,mBAAqB,GACrB,KAAA,IAAM4B,EAAO,CAAC,MAAO2L,EAAG,IAAI,EAAE,KAAK,GAAG,CAAC,EAC5C,KAAK,IAAI,aAAa,EAEtB,KAAK,aAAa,EAAI,EAElBD,EAAA,UAAU,KAAK,IAAI,CACzB,CAEO,aAAc,CACnB,OAAO,KAAK,kBACd,CAEO,aAAaE,EAAY,GAA6B,CACxD,GAAA,KAAK,eAAiB,CAACA,EACxB,OAAO,KAAK,cAGR,MAAAC,EAAgB,CAACC,EAAoBC,IAAoB,CAC7D,MAAMC,EAAa,MAAM,KAAKF,EAAG,UAAU,EAC3C,UAAUG,KAAaD,EACrBF,EAAG,YAAYG,CAAS,EAGvB,GAACF,EAAM,SAAS,OAIT,UAAAG,KAASH,EAAM,QACpBD,EAAG,WAAW,SAASI,EAAM,SAAS,GAIzCJ,EAAG,YAAYI,EAAM,UAAWA,EAAM,QAASA,EAAM,gBAAgB,CACvE,EAGIC,EAAoB,CAACR,EAAiBI,IAAoB,CAC9D,MAAMD,EAAKH,EAAG,kBAAkBI,EAAM,IAAI,EAC1CF,EAAcC,EAAIC,CAAK,CAAA,EAGrB,GAAA,CACF,IAAI3D,EAAU,UAAU,KAAK,KAAK,KAAM,KAAK,OAAO,EAEpD,GAAG,CAACA,EACF,OAAO,QAAQ,eAEXqB,EAAO,CACb,YAAK,IAAI,MAAM,mBAAqBA,EAAgB,OAAO,EAC3D,KAAK,mBAAqB,GACnB,QAAQ,OAAOA,CAAK,CAC7B,CAEA,IAAI2C,EAAW,GACf,kBAAW,IAAM,CACXA,GACMhE,EAAA,QAAQtB,EAAU,oBAAoB,CAAU,GAEzD,GAAI,EAEA,KAAK,cAAgB,IAAI,QAAqB,CAAC3F,EAASuB,IAAW,CAChE0F,EAAA,UAAa1G,GAAU,CAClB0K,EAAA,GACX,MAAMT,EAAKvD,EAAQ,OACnB,IAAIiE,EAAY,GAEhB,KAAK,IAAI,QAAQ,EAEdV,EAAA,QAAWlC,GAAU,CACtB,KAAK,mBAAqB,GACrB,KAAA,IAAI,MAAM,8CAA+CA,CAAK,EACnE/G,EAAO+G,CAAK,CAAA,EAGXkC,EAAA,QAAWzJ,GAAM,CACb,KAAA,IAAI,MAAM,UAAWA,CAAC,EAC1B,CAAAmK,GAAa,KAAK,cAAa,EAG/BV,EAAA,QAAWzJ,GAAM,CACb,KAAA,IAAI,MAAM,SAAUA,CAAC,EAC1B,MAAMoK,EAAcpK,EAAE,OAEjB,KAAA,aAAamK,EAAY,EAAI,EAE/BC,EAAY,SACbA,EAAY,QAAQpK,CAAC,EAGvByJ,EAAG,MAAM,CAAA,EAGRA,EAAA,gBAAmBzJ,GAAM,CACrB,KAAA,IAAI,MAAM,uBAAuB,CAAA,EAGhCf,EAAA,KAAK,GAAKwK,CAAE,CAAA,EAGdvD,EAAA,QAAW1G,GAAU,CAChB0K,EAAA,GACX,KAAK,mBAAqB,GACrB,KAAA,IAAI,MAAM,8CAA+C1K,CAAK,EACnEgB,EAAOhB,CAAK,CAAA,EAGN0G,EAAA,gBAAmB1G,GAAU,CACxB0K,EAAA,GACX,KAAK,IAAI,KAAK,8BAA+B1K,EAAM,WAAY,KAAMA,EAAM,UAAU,EAErF,MAAM6K,EAAS7K,EAAM,OACfiK,EAAKY,EAAO,OACb,KAAA,OAAO,QAASR,GAAU,CAO7B,GAAG,CAACJ,EAAG,iBAAiB,SAASI,EAAM,IAAI,EACzCI,EAAkBR,EAAII,CAAK,MACtB,CAEL,MAAMD,EADMS,EAAO,YACJ,YAAYR,EAAM,IAAI,EACrCF,EAAcC,EAAIC,CAAK,CACzB,CAAA,CACD,CAAA,CACH,CACD,CACH,CAEA,OAAc,OAAgCJ,EAAO,CACnD,OAAO,KAAK,UAAU,KAAMa,GAAaA,EAAS,OAASb,EAAG,IAAI,GAAK,IAAID,EAAIC,CAAE,CACnF,CAEA,OAAc,eAAec,EAAgB,CACtC,KAAA,UAAU,QAAShF,GAAY,CAC/B,GAAAgF,GAAYA,IAAahF,EAC1B,OAGF,MAAMkE,EAAKlE,EAAQ,GAChBkE,IACDA,EAAG,QAAU,IAAM,CAAA,EACnBA,EAAG,MAAM,EACX,CACD,CACH,CACF,EArKED,EAAe,UAAmB,GAD7B,IAAMgB,EAANhB,EAwKP,MAAqBiB,EAAuF,CAK1G,YAAYhB,EAAOiB,EAA2C,CAC5D,KAAK,UAAYA,EACZ,KAAA,IAAM5M,EAAO,CAAC,MAAO2L,EAAG,KAAMiB,CAAS,EAAE,KAAK,GAAG,CAAC,EAClD,KAAA,IAAMF,EAAI,OAAOf,CAAE,CAC1B,CAoCO,OAAO1E,EAA8B2F,EAAsC,CAE1E,MAAAC,EAAU,MAAM,QAAQ5F,CAAS,EACvC,OAAI4F,IACU5F,EAAA,CAAG,EAAA,OAAOA,CAAS,GAG1B,KAAK,eAAe,YAAc6F,GAAgB,CACjD,MAAAxE,EAAYrB,EAAuB,IAAKA,GAAc6F,EAAY,OAAO7F,CAAS,CAAC,EAClF,OAAA4F,EAAUvE,EAAWA,EAAS,CAAC,CAAA,EACqB,GAAIsE,CAAS,CAC5E,CAEO,MAAMA,EAAsC,CAC1C,OAAA,KAAK,eAAe,YAAcE,GAAgBA,EAAY,MAAS,EAAkB,GAAIF,CAAS,CAC/G,CAEO,KAAK3F,EAA8BzE,EAAoBoK,EAAuB,CAY7E,MAAAC,EAAU,MAAM,QAAQ5F,CAAS,EACvC,OAAI4F,IACU5F,EAAA,CAAG,EAAA,OAAOA,CAAS,EACvBzE,EAAA,CAAG,EAAA,OAAOA,CAAK,GAGlB,KAAK,eAAe,YAAcsK,GAAgB,CACvD,MAAMxE,EAAYrB,EAAuB,IAAI,CAACA,EAAW8F,IAAQD,EAAY,IAAItK,EAAMuK,CAAG,EAAG9F,CAAS,CAAC,EAChG,OAAA4F,EAAUvE,EAAWA,EAAS,CAAC,CAAA,EACmB,GAAIsE,CAAS,CAC1E,CA6EO,IAAO3F,EAA8B2F,EAAkD,CAGtF,MAAAC,EAAU,MAAM,QAAQ5F,CAAS,EACvC,GAAI4F,GAMJ,GAAU,CAAC5F,EAAU,OACZ,OAAA,QAAQ,QAAQ,CAAA,CAAE,MAPd,CACX,GAAG,CAACA,EACK,OAGGA,EAAA,CAAG,EAAA,OAAOA,CAAS,CAAA,CAKjC,OAAO,KAAK,eAAkB,WAAa6F,GAAgB,CACnD,MAAAxE,EAAYrB,EAAuB,IAAKA,GAAc6F,EAAY,IAAI7F,CAAS,CAAC,EAC/E,OAAA4F,EAAUvE,EAAWA,EAAS,CAAC,CAAA,EACkB,GAAIsE,CAAS,CACzE,CAEQ,eACNI,EACAzK,EACAhC,EACAqM,EAAY,KAAK,UACjB,CACI,IAAAK,EAEJ,OAAG1M,IACD0M,EAAO,YAAY,MACd,KAAA,IAAI1M,EAAM,SAAS,GAGnB,KAAK,IAAI,aAAe,EAAA,KAAMoL,GAC5B,IAAI,QAAW,CAACxK,EAASuB,IAAW,CAMnC,MAAA4J,EAAcX,EAAG,YAAY,CAACiB,CAAS,EAAGI,EAAM,CAAC,WAAY,SAAA,CAAU,EAEvEE,EAAU,IAAM,CACpB,aAAa9F,CAAO,EACpB1E,EAAO4J,EAAY,KAAK,CAAA,EAIpBa,EAAa,IAAwB,CACzC,aAAa/F,CAAO,EAEjB7G,GACI,KAAA,IAAIA,EAAM,QAAS,YAAY,MAAQ0M,CAAA,EAQ9C,MAAMG,EAAUnF,EAAS,IAAKoF,GAAMA,EAAE,MAAM,EAC5ClM,EAAQ0L,GAAUO,EAAUA,EAAQ,CAAC,CAAC,CAAA,EAGxCd,EAAY,QAAUY,EAGtB,MAAMI,EAA6BN,IAAS,YACzCM,IACDhB,EAAY,WAAa,IAAMa,EAAA,GAG3B,MAAA/F,EAAU,WAAW,IAAM,CAC/B,KAAK,IAAI,MAAM,2BAA4BkF,EAAa/L,CAAG,GAC1D,GAAK,EAOFgN,EAAiBhL,EAAS+J,EAAY,YAAYM,CAAS,CAAC,EAE5DC,GAAU,MAAM,QAAQU,CAAc,EACtCtF,EAAyB4E,GAAUU,EAAiB,CAAA,EAAG,OAAOA,CAAc,EAElF,GAAGD,EACD,OAGF,MAAM5J,GAASuE,EAAS,OACxB,IAAIuF,GAAO9J,GAEX,MAAM+J,GAAoB,IAAM,CAC3BnB,EAAY,OAIX,EAAEkB,IACJL,EAAA,CACF,EAGF,QAAQ7J,EAAI,EAAGA,EAAII,GAAQ,EAAEJ,EAAG,CACxB,MAAA8E,EAAUH,EAAS3E,CAAC,EAC1B8E,EAAQ,QAAU8E,EAClB9E,EAAQ,UAAYqF,EACtB,CAAA,CACD,CACF,CACH,CAEO,OAAUb,EAAqC,CAC7C,OAAA,KAAK,eAAoB,WAAaE,GAAgBA,EAAY,OAAU,EAAmB,GAAIF,CAAS,CACrH,CAiDF,CChgBA,MAAMtO,EAAM,KACNoP,GAAiB,SAAS,SAAW,KAAO,SAAS,SAAW,SAAS,SAAS,MAAM,GAAG,EAAE,MAAM,EAAG,EAAE,EAAE,KAAK,GAAG,EAAI,IAGtHC,GAAoB,MAC1B,IAAIC,GAAe,EACfC,GAA8B,GAyBlC,MAAMC,EAA8E,CAIlF,YACEnC,EACAiB,EACQmB,EAGR,CAHQA,KAAAA,SAAAA,EANV,KAAQ,MAA0B,GAUhC,KAAK,QAAU,IAAIpB,GAAchB,EAAIiB,CAAS,CAChD,CAEQ,WAAoCpD,EAAQ,CAC5C,MAAAjH,EAAW,KAAK,SAASiH,CAAG,EAClC,OAAO,OAAOjH,GAAc,WAAaA,EAAA,EAAaA,CACxD,CAEO,IAA6BiH,EAAQ,CAC1C,OAAG,KAAK,MAAM,eAAeA,CAAG,EACvB,KAAK,MAAMA,CAAG,EAGP,KAAK,QAAQ,IAAIA,CAAa,EAC/B,KAAMhH,GAAUA,EAAO,IAAM,EAAuB,EAAE,KAAMA,GACtE,KAAK,MAAM,eAAegH,CAAG,EACvB,KAAK,MAAMA,CAAG,GAGbhH,MAAA,KAAK,WAAWgH,CAAG,GAEtB,KAAK,MAAMA,CAAG,EAAIhH,EAC1B,CACH,CAEO,UAAmCgH,EAAQ,CAC1C,MAAAhH,EAAQ,KAAK,IAAIgH,CAAG,EAC1B,GAAGhH,aAAiB,QACZ,KAAA,cAGD,OAAAA,CACT,CAEA,MAAa,IAA6BgH,EAAQhH,EAAmB,CACnE,MAAMwL,EAAS,KAAK,MAAMxE,CAAG,GAAK,KAAK,SAASA,CAAG,EAChD,GAAA,CAAAsB,GAAUkD,EAAQxL,CAAK,EAIrB,MAAA,MAAMgH,CAAG,EAAIhH,EAEd,GAAA,CACG,KAAA,QAAQ,KAAKgH,EAAehH,CAAK,OAC3B,CAEb,EACF,CACF,CAQA,MAAMuL,GAAwB,CAC5B,gBAAiB,EACjB,UAAW,CACT,uBAAwB,yBACxB,mBAAoB,eACpB,qBAAsB,UACxB,EACA,cAAe,CAAC,CAClB,EAEME,EAAS,IAAIH,GAAoDnD,GAAgB,UAAWoD,EAAQ,EAG1G,UAAUzK,KAAKyK,GACbE,EAAO,IAAI3K,CAAsB,EAGnChF,EAAI,iBAAiB,OAASoD,GAAU,CAChC,MAAA0J,EAA8B1J,EAAM,KAAK,KAAK,EACpDnB,EAAI,OAAQ,CAAC,GAAG6K,CAAI,CAAA,EAEhB,GAAA,CACF,KAAM,CAAC8C,EAAWC,EAAUC,CAAI,EAAI,CAClCH,EAAO,UAAU,iBAAiB,EAClCA,EAAO,UAAU,eAAe,EAChCA,EAAO,UAAU,WAAW,CAAA,EAGxBI,EAAU,KAAK,MACrB,GACEC,GAAyB,GACzBJ,GACAG,EAAUH,EAEV,KAAM,yCAAyC,KAAK,MAAMA,EAAYG,GAAW,GAAK,CAAC,OAIzF,GAD0B,KAAK,IAAI,EAAIT,IAAiBD,IAAqBE,GAErE,KAAA,sDAGR,MAAMU,EAAsBC,GAAiBpD,EAAK+C,EAAUC,CAAI,EAChE1M,EAAM,UAAU6M,CAAmB,QAC7BrP,EAAK,CACXqB,EAAIrB,CAAG,CAUT,CACF,CAAC,EAEDZ,EAAI,iBAAiB,oBAAsBoD,GAAU,CACnD,MAAM+M,EAAe/M,EAAM,aAC3BnB,EAAI,wBAAyBkO,CAAY,EACzCA,EAAa,MAAM,EAEnB,MAAMC,EAAShN,EAAM,OAClB,GAAAgN,IAAW,UAAYJ,KAA4B,CACpD/N,EAAI,kBAAkB,EACtB0N,EAAO,IAAI,kBAAmB,KAAK,IAAA,EAAQ,KAAO,EAClD,MACF,CAEA,MAAMU,EAA+BF,EAAa,KAClD,GAAG,CAACE,EACF,OAGI,MAAAnN,EAAUlD,EAAI,QAAQ,SAAS,CACnC,KAAM,QAAA,CACP,EAAE,KAAMsQ,GAAe,CACtBD,EAAK,OAASD,EACQG,EAAAF,EACtB,QAAQrL,EAAI,EAAGA,EAAIsL,EAAW,OAAQ,EAAEtL,EAAG,CACnC,MAAAwL,EAASF,EAAWtL,CAAC,EAC3B,GAAG,UAAWwL,EAAQ,CACpBA,EAAO,MAAM,EACMxF,EAAA,WAAW,YAAauF,EAAqBC,CAAM,EAChDD,EAAA,OACtB,MACF,CACF,CAEG,GAAAvQ,EAAI,QAAQ,WACN,OAAA,QAAQ,QAAQ2P,EAAO,IAAI,eAAe,CAAC,EAAE,KAAME,GACjD7P,EAAI,QAAQ,WAAW6P,EAAS,SAAWT,EAAc,CACjE,CACH,CACD,EAAE,MAAOjE,GAAU,CACdlJ,EAAA,MAAM,yBAA0BkJ,CAAK,CAAA,CAC1C,EAED/H,EAAM,UAAUF,CAAO,CACzB,CAAC,EAEDlD,EAAI,iBAAiB,oBAAqByQ,EAAmB,EAE7D,MAAMC,MAAuC,IAC7C,IAAIH,EASJ,SAASE,GAAoBrN,EAA0B,CACrDuN,GAAwBvN,EAAM,YAAY,CAC5C,CAEA,SAASuN,GAAwBR,EAA4B,CAC3DO,EAAc,OAAOP,CAAY,CACnC,CAEO,SAASS,GAAsBC,EAAc,CAClD,UAAUV,KAAgBO,EACpB,GAAA,CACC,GAAAG,GAAOV,EAAa,MAAQU,EAC7B,SAGFV,EAAa,MAAM,EACnBO,EAAc,OAAOP,CAAY,OACxB,CAAC,CAGV,IAAAjN,EACD,MAAA,qBAAsBlD,EAAI,aACjBkD,EAAAlD,EAAI,aAAa,iBAAiB,CAAC,IAAA6Q,EAAI,EAAE,KAAMH,GAAkB,CACjE,QAAA1L,EAAI,EAAGN,EAAMgM,EAAc,OAAQ1L,EAAIN,EAAK,EAAEM,EAChD,GAAA,CACF0L,EAAc1L,CAAC,EAAE,aACR,CAAC,CACd,CACD,EAAE,MAAOmG,GAAU,CACdlJ,EAAA,MAAM,4BAA6BkJ,CAAK,CAAA,CAC7C,EAEDjI,EAAU,QAAQ,UAGbA,CACT,CAEA,SAAS8M,IAA2B,CAC3B,OAAA5P,EACT,CAEA,SAAS8P,GAAiBpD,EAA6B+C,EAAwCC,EAAgC,CACzH,IAAAgB,EAAQhE,EAAI,OAAS,WACrBiE,EAAOjE,EAAI,aAAe,GAC1BkE,EAEDlE,EAAI,SACFA,EAAI,OAAO,WACHkE,EAAA,GAAK,CAAClE,EAAI,OAAO,WAClBA,EAAI,OAAO,QACVkE,EAAA,GAAK,CAAClE,EAAI,OAAO,QAEjBkE,EAAAlE,EAAI,OAAO,SAAW,IAI/BA,EAAA,OAAO,OAAS,GAAKkE,EACzB,IAAIH,EAAM,OAASG,EAEnB,MAAMC,EAAaD,EAAS,IAAMlE,EAAI,OAAO,OAC1C,GAAAoE,EAAe,IAAID,CAAU,EAAG,CACjC,MAAM9F,EAAQ,gBACV,MAAAlJ,EAAA,KAAKkJ,EAAO2B,CAAG,EACnBoE,EAAe,OAAOD,CAAU,EAC1B9F,CACR,CAEG0E,GAAU,YACHiB,EAAA,WACRC,EAAOjB,EAAK,uBACNe,EAAA,gBAGR,MAAMM,EAA+F,CAAC,CACpG,OAAQ,SACR,MAAOrB,EAAK,kBACd,CAAA,EAKMsB,EAA2C,CAC/C,KAAAL,EACA,KAAMzE,GACN,IAAAuE,EACA,KAAM/D,EACN,QAAAqE,EACA,MAAO5E,GACP,OAAQO,EAAI,OAAO,SAAW,GAAA,EAGhC,OAAA7K,EAAI,cAAe6O,EAAOC,EAAMjE,EAAKsE,CAAmB,EAE5BpR,EAAI,aAAa,iBAAiB8Q,EAAOM,CAAmB,EAE7D,MAAOjG,GAAU,CACtClJ,EAAA,MAAM,4BAA6BkJ,CAAK,CAAA,CAC7C,CACH,CAEgB,SAAAkG,GAAOvG,EAAqCwG,EAA6B,CACvFhC,GAAe,KAAK,MACpBC,GAA8BzE,EAAQ,mBAEnCyF,GAAuBe,IACLtG,EAAA,WAAW,YAAauF,EAAqBe,CAAM,EAChDf,EAAA,QAGrBzF,EAAQ,MACF6E,EAAA,IAAI,YAAa7E,EAAQ,IAAI,EAGnCA,EAAQ,UACF6E,EAAA,IAAI,gBAAiB7E,EAAQ,QAAQ,CAEhD,CAEA,MAAMoG,MAA0C,IACzC,SAASK,GAAoBzG,EAAiB,CACnDoG,EAAe,IAAIpG,EAAS,KAAK,IAAK,CAAA,CACxC,CAEA,YAAY,IAAM,CACV,MAAA0G,EAAO,KAAK,MACHN,EAAA,QAAQ,CAACO,EAAOvG,IAAQ,CACjCsG,EAAOC,EAAS,KAClBP,EAAe,OAAOhG,CAAG,CAC3B,CACD,CACH,EAAG,GAAK,GAAI,EC3WZ,MAAMwG,GAAQ,KAAK,MAAQ,KAAK,OAAA,EAAW,IAAY,ECA/B,SAAAC,EAAoBC,EAAiBC,EAAS,CAC9D,MAAApD,EAAMmD,EAAM,QAAQC,CAAI,EAE9B,OADgBpD,IAAQ,GAAK,OAAYmD,EAAM,OAAOnD,EAAK,CAAC,KAC3C,CAAC,CACpB,CC4DA,MAAqBqD,EAA4D,CAU/E,YAAYC,EAAwB,CAClC,KAAK,aAAaA,CAAY,CAChC,CAEO,aAAaA,EAA6B,CAC/C,KAAK,aAAeA,EACpB,KAAK,UAAY,GACjB,KAAK,gBAAkB,EACzB,CAEO,iBAA4CC,EAAS/N,EAAwBgO,EAA6C,CjCvEnI,IAAAC,EiCwEU,MAAAC,EAA+C,CAAC,SAAAlO,EAAU,QAAAgO,GAGhE,KAFCC,EAAA,KAAK,WAALF,KAAAE,EAAAF,OAA6B,MAAO,IAAIG,CAAc,EAEpD,KAAK,gBAAgB,eAAeH,CAAI,IACzC/N,EAAS,GAAG,KAAK,gBAAgB+N,CAAI,CAAC,EAElCC,GAAqC,MAAM,CAC7C,KAAK,UAAUD,CAAI,EAAE,OAAOG,CAAc,EAC1C,MACF,CAIJ,CAEO,2BAA2BrF,EAE/B,CACD,UAAU9H,KAAK8H,EACb,KAAK,iBAAiB9H,EAAG8H,EAAI9H,CAAC,CAAC,CAEnC,CAEO,oBACLgN,EACA/N,EACAgO,EACA,CACG,GAAA,KAAK,UAAUD,CAAI,GACpB,UAAUI,KAAK,KAAK,UAAUJ,CAAI,EAC7B,GAAAI,EAAE,WAAanO,EAAU,CAC1B,KAAK,UAAU+N,CAAI,EAAE,OAAOI,CAAC,EAC7B,KACF,EAIN,CAEU,uBACRJ,EACAtR,KACGC,EACH,CACA,IAAI8G,EAAa0D,EACb,GAAA,CACO1D,EAAA/G,EAAS,SAAS,GAAGC,CAAI,QAC5BC,EAAK,CACHuK,EAAAvK,CAEV,CAMA,GAJIF,EAAS,SAAqC,MAC3C,KAAA,oBAAoBsR,EAAMtR,EAAS,QAAQ,EAG/CyK,EACK,MAAAA,EAGD,OAAA1D,CACT,CAEQ,eACNuK,EACAK,KACG1R,EACH,CACG,KAAK,eACD,KAAA,gBAAgBqR,CAAI,EAAIrR,GAGzB,MAAA2R,EAAsDD,GAAkB,GAExEtR,EAAY,KAAK,UAAUiR,CAAI,EACrC,GAAGjR,EACD,UAAUL,KAAYK,EAAW,CAC/B,MAAM0G,EAAS,KAAK,uBAAuBuK,EAAMtR,EAAU,GAAGC,CAAI,EAC/D2R,GACDA,EAAI,KAAK7K,CAAM,CAEnB,CAGK,OAAA6K,CACT,CAEO,wBAAmDN,KAAYrR,EAAmC,CACvG,OAAO,KAAK,eAAeqR,EAAM,GAAM,GAAGrR,CAAI,CAChD,CAGO,cACLqR,KACGrR,EACH,CAEA,KAAK,eAAeqR,EAAM,GAAO,GAAGrR,CAAI,CAC1C,CAEO,SAAU,CACf,KAAK,UAAY,GACjB,KAAK,gBAAkB,EACzB,CACF,CC7FA,MAAM4R,GAAY,GAMlB,MAAqBC,WAMXV,EAA2B,CA4BnC,YAAsBW,EAAoB,CACxC,MAAM,EAAK,EADS,KAAA,UAAAA,EA8JZ,KAAA,UAAarP,GAAwB,CAC7C,MAAMsP,EAAatP,EAAM,KAGnBkO,EAA6BlO,EAAM,QAAUA,EAAM,cAGzD,KAAK,eAAesP,EAAK,IAAI,EAAEA,EAAMpB,EAAQlO,CAAK,CAAA,EAqE1C,KAAA,kBAAqBsP,GAAqB,CAClD,KAAM,CAAC,OAAArI,EAAQ,OAAA5C,EAAQ,MAAA0D,CAAA,EAASuH,EAAK,QAC/BrO,EAAW,KAAK,SAASgG,CAAM,EACjChG,IAIC,KAAA,OAAS,KAAK,IAAI,MAAM,OAAQA,EAAS,SAAUoD,EAAQ0D,CAAK,EAC1D,UAAAuH,EAAK,QAAUrO,EAAS,OAAO8G,CAAK,EAAI9G,EAAS,QAAQoD,CAAM,EACnE,OAAA,KAAK,SAAS4C,CAAM,EAAA,EAGnB,KAAA,eAAkBqI,GAAkB,CAC5C,MAAM5H,EAAU4H,EAAK,QACfrO,EAAW,KAAK,SAASyG,EAAQ,MAAM,EAC7C,GAAG,CAACzG,EACF,OAIF,MAAMsO,EAAqDtO,EAAS,QAwB9DuO,EAAwB,CAC5B,OAAQ9H,EAAQ,OAChB,OAAQA,EAAQ,OAAU,WAAYA,EAAU,QAAQ,QAAQA,EAAQ,MAAM,EAAI,QAAQ,OAAOA,EAAQ,KAAK,EAAK,IAAI,QAAQ,CAACjI,EAASuB,IAAW,CAClJC,EAAS,QAAUxB,EACnBwB,EAAS,OAASD,CAAA,CACnB,CAAA,EAGHuO,EAAgBC,CAAG,EAEhB9H,EAAQ,QACF,OAAA,KAAK,SAASA,EAAQ,MAAM,CACrC,EAGF,KAAU,gBAAkB,CAAC4H,EAAgBpB,EAA4BlO,IAAwB,CAC/F,KAAK,SAAS,KAAK,WAAW,OAAQ,MAAS,EAAGA,EAAM,MAAM,CAAA,EAGhE,KAAU,gBAAkB,CAACsP,EAAgBpB,EAA4BlO,IAAwB,CAC/F,MAAMyP,EAAc,KAAK,aAAa,IAAIvB,CAAM,EAC7CuB,IACI,KAAA,aAAa,OAAOvB,CAAM,EACnBuB,IACd,EAGF,KAAU,iBAAmB,CAACH,EAAiBpB,EAA4BlO,IAAwB,CACjG,KAAK,WAAWkO,CAAM,CAAA,EAGxB,KAAU,iBAAmB,CAACoB,EAAiBpB,EAA4BlO,IAAwB,CAK3F,MAAA0P,EAAyB,CAAC,KAAM1P,EAAM,KAAM,OAAQA,EAAM,OAAQ,cAAeA,EAAM,aAAa,EACrGsP,EAAA,QAAQ,QAASA,GAAS,CAE7BI,EAAS,KAAOJ,EAChB,KAAK,UAAUI,CAAQ,CAAA,CACxB,CAAA,EAQH,KAAU,gBAAkB,CAACJ,EAAgBpB,EAA4BlO,IAAwB,CAC/F,MAAM6G,EAAKyI,EAAK,QACb,KAAK,eAAe,IAAIzI,CAAE,IAIxB,KAAA,eAAe,IAAIA,EAAIqH,CAAM,EACxB,UAAA,MAAM,QAAQrH,EAAI,IAAM,CAC3B,KAAA,iBAAiB,OAAWqH,EAAQ,MAAS,EAC7C,KAAA,eAAe,OAAOrH,CAAE,CAAA,CAC9B,EAAA,EAGH,KAAU,kBAAoB,MAAMyI,EAAkBpB,EAA4BlO,IAAwB,CACxG,MAAM6G,EAAKyI,EAAK,GACVK,EAAYL,EAAK,QAEnB,IAAAM,EACAC,EAAwBC,EACxBH,EAAU,OACQC,EAAA,CAAC,OAAQ/I,GAChBgJ,EAAA,KAAK,WAAW,SAAUD,CAAiB,GAGvDD,EAAU,UACDG,EAAA,KAAK,WAAW,MAAO,CAC/B,OAAQjJ,EACR,OAAQ,EAAA,CACT,GAGC,IAAAkJ,EACA,GAAA,CACF,MAAMpS,EAAY,KAAK,UAAUgS,EAAU,IAAI,EAC5C,GAAA,CAAChS,GAAW,KACP,MAAA,IAAI,MAAM,aAAa,EAG/B,MAAML,EAAWK,EAAU,OAAO,EAAE,OAAO,MAGvC,IAAA0G,EAAS,KAAK,uBAAuBsL,EAAU,KAAMrS,EAAUqS,EAAU,QAASzB,EAAQlO,CAAK,EACnG,GAAG2P,EAAU,KACX,OAKF,GAFAI,EAAY1L,aAAkB,QAE3ByL,EAAS,CACV,MAAMxD,EAAS,CAACyD,EAKhB,GAJAD,EAAQ,QAAQ,OAASxD,EACtBA,IAAQwD,EAAQ,QAAQ,OAASzL,GAC/B,KAAA,SAASyL,EAAS5B,CAAM,EAE1B5B,EACD,MAEJ,CAEGyD,IACD1L,EAAS,MAAMA,GAGjBuL,EAAkB,OAASvL,QACrB0D,EAAO,CAEb,GADA,KAAK,IAAI,MAAM,qBAAsBA,EAAOuH,CAAI,EAC7CK,EAAU,KACX,OAGC,GAAAG,GAAWA,EAAQ,QAAQ,OAAQ,CACpCA,EAAQ,QAAQ,MAAQ/H,EACnB,KAAA,SAAS+H,EAAS5B,CAAM,EAC7B,MACF,CAEA0B,EAAkB,MAAQ7H,CAC5B,CAEK,KAAA,SAAS8H,EAAY3B,CAAM,CAAA,EAnZhC,KAAK,YAAc,GACnB,KAAK,UAAY,GACZ,KAAA,iBAAmB,IACxB,KAAK,OAAS,EACd,KAAK,SAAW,GACX,KAAA,YAAc,IACnB,KAAK,IAAM5P,EAAO,MAAQ+Q,EAAY,IAAMA,EAAY,GAAG,EAC3D,KAAK,MAAQ1S,GACR,KAAA,cAAgB,IAChB,KAAA,mBAAqB,IAE1B,KAAK,eAAiB,CACpB,OAAQ,KAAK,kBACb,IAAK,KAAK,eACV,OAAQ,KAAK,kBACb,KAAM,KAAK,gBACX,KAAM,KAAK,gBACX,MAAO,KAAK,iBAEZ,KAAM,KAAK,gBACX,MAAO,KAAK,gBAAA,CAEhB,CAEO,oBAAoBkE,EAAgD,CACzE,KAAK,iBAAmBA,CAC1B,CAMO,WAAWmP,EAA0B,CAC1C,KAAK,iBAAiBA,CAAI,EAC1B,KAAK,eAAeA,CAAI,CAC1B,CAEO,iBAAiBA,EAAkB,CACnC,KAAA,YAAY,KAAKA,CAAI,EACrBA,EAAA,iBAAiB,UAAW,KAAK,SAAgB,CACxD,CAEO,eAAeA,EAAgB,CAWjC,GAVE,KAAA,IAAI,KAAK,qBAAqB,EAElCA,EAAqB,QAAQ,EAEzB,KAAA,UAAU,KAAKA,CAAI,EAMrB,OAAO,OAAY,KAAeb,GACnC,GAAG,UAAW,UAAW,CACvB,MAAMtI,EAAK,CAAC,OAAQyH,GAAO,KAAK,WAAa,GAAI,KAAK,OAAA,EAAW,WAAa,CAAC,EAAE,KAAK,GAAG,EACpF,KAAA,IAAI,KAAK,eAAgBzH,CAAE,EAC1B,MAAA/G,EAAU,IAAI,QAAeL,GAAY,KAAK,UAAU,IAAIuQ,EAAM,CAAC,QAAAvQ,EAAS,GAAAoH,CAAG,CAAA,CAAC,EACrF,KAAK,IAAM,KAAK,UAAU,OAAOmJ,CAAI,CAAC,EAC7B,UAAA,MAAM,QAAQnJ,EAAI,KAC1B,KAAK,eAAemJ,CAAI,EACjBlQ,EACR,CAAA,MAEM,OAAA,iBAAiB,eAAgB,IAAM,CAC5C,MAAMwP,EAAO,KAAK,WAAW,QAAS,MAAS,EAC1C,KAAA,YAAY,OAAWA,CAAI,CAAA,CACjC,EAIL,KAAK,eAAe,CACtB,CAEO,eAAeU,EAAgB,CACpC,MAAMC,EAAO,KAAK,UAAU,IAAID,CAAI,EAChCC,GAIJ,KAAK,SAAS,KAAK,WAAW,OAAQA,EAAK,EAAE,EAAGD,CAAI,CACtD,CAuCO,WAAWA,EAAkB,CAC7B,KAAA,IAAI,KAAK,oBAAoB,EAEjBzB,EAAA,KAAK,YAAayB,CAAI,EACtBzB,EAAA,KAAK,UAAWyB,CAAW,EAEvCA,EAAA,sBAAsB,UAAW,KAAK,SAAgB,EAC1DA,EAAqB,QAAQ,EAE9B,KAAK,mBAAmBA,CAAW,EAElB,KAAK,UAAU,IAAIA,CAAgB,GAC1C,QAAQ,EAEZ,MAAAjI,EAAQ3C,EAAU,mBAAmB,EACjC,UAAAyB,KAAM,KAAK,SAAU,CACvB,MAAAyI,EAAO,KAAK,SAASzI,CAAE,EAC1ByI,EAAK,OAASU,IACfV,EAAK,OAAOvH,CAAK,EACV,OAAA,KAAK,SAASlB,CAAE,EAE3B,CACF,CAEU,YAAYmJ,EAA6BV,EAAY,EAC/C,MAAM,QAAQU,CAAI,EAAIA,EAAQA,EAAO,CAACA,CAAI,EAAI,KAAK,WAC3D,QAASA,GAAS,CAKjBE,EAAA,YAAYZ,EAAMA,EAAK,QAAe,CAAA,CAC5C,CACH,CAYA,MAAgB,gBAAiB,CAGgC,KAAK,mBAIpE,KAAK,iBAAmB,GAItB,MAAM,QAAQ,UAIX,KAAA,OAAS,KAAK,IAAI,MAAM,2BAA4B,KAAK,QAAQ,IAAA,EAEtE,KAAK,QAAQ,QAAQ,CAACa,EAAWH,IAAS,CACxC,IAAII,EAAgBD,EACH,CACX,IAAAE,EACJD,EAAQ,CAAA,EACED,EAAA,QAASb,GAAS,CACvBA,EAAK,UACMe,EAAA,OACZD,EAAM,KAAKd,CAAI,IAEXe,IACFA,EAAY,KAAK,WAAW,QAAS,CAAE,CAAA,EACvCD,EAAM,KAAKC,CAAS,GAGZA,EAAA,QAAQ,KAAKf,CAAI,EAC7B,CACD,CACH,CAEA,MAAMgB,EAAQN,EAAO,CAACA,CAAI,EAAI,KAAK,UAC/BM,EAAM,SAIJF,EAAA,QAASd,GAAS,CAKlB,GAAA,CAIG,KAAA,YAAYgB,EAAOhB,CAAI,QAEtB9R,EAAK,CACX,KAAK,IAAI,MAAM,qBAAsBA,EAAK8R,EAAMgB,CAAK,CACvD,CAAA,CACD,EAEI,KAAA,QAAQ,OAAON,CAAI,EAAA,CACzB,EAED,KAAK,OAAS,KAAK,IAAI,MAAM,gBAAgB,EAE7C,KAAK,iBAAmB,GAC1B,CAiLU,WAA+ExR,EAASkJ,EAAuB6I,EAA8B,CAC9I,MAAA,CACL,KAAA/R,EACA,QAAAkJ,EACA,GAAI,KAAK,SACT,SAAA6I,CAAA,CAEJ,CAEU,iBAAiB/R,EAAckJ,EAAc8I,EAAmBC,EAAiBF,EAAuC,CACzH,OAAA,KAAK,WAAW,SAAU,CAC/B,KAAA/R,EACA,QAAAkJ,EACA,QAAA8I,EACA,KAAMC,GACLF,CAAQ,CACb,CAEU,SAASjB,EAAYU,EAAiB,CAC9C,IAAII,EAAQ,KAAK,QAAQ,IAAIJ,CAAI,EAC7BI,GACF,KAAK,QAAQ,IAAIJ,EAAMI,EAAQ,CAAE,CAAA,EAGnCA,EAAM,KAAKd,CAAI,EACf,KAAK,eAAe,CACtB,CAEO,WAAiC9Q,EAASkJ,EAAiCsI,EAAiBO,EAA2B,CAC5H,MAAMjB,EAAO,KAAK,iBAAiB9Q,EAAgBkJ,EAAS,OAAW,GAAM6I,CAAQ,EAChF,KAAA,SAASjB,EAAMU,CAAI,CAC1B,CAIO,OAA6BxR,EAASkJ,EAAiC8I,EAAmBR,EAAiBO,EAA2B,CAC3I,KAAK,OAAS,KAAK,IAAI,MAAM,QAAS/R,EAAMkJ,CAAO,EAE/C,IAAA4H,EACJ,MAAMxP,EAAU,IAAI,QAAsC,CAACL,EAASuB,IAAW,CAC7EsO,EAAO,KAAK,iBAAiB9Q,EAAgBkJ,EAAS8I,EAAS,OAAWD,CAAQ,EAC7E,KAAA,SAASjB,EAAK,EAAE,EAAI,CAAC,QAAA7P,EAAS,OAAAuB,EAAQ,SAAUxC,EAAgB,KAAAwR,GAChE,KAAA,SAASV,EAAMU,CAAI,CAAA,CACzB,EAED,GAAG7S,GAAW,CACZ2C,EAAQ,QAAQ,IAAM,CACpB,cAAc4Q,CAAQ,CAAA,CACvB,EAEK,MAAAA,EAAW9T,EAAI,YAAY,IAAM,CACrC,KAAK,IAAI,MAAM,2BAA4B0S,EAAMU,CAAI,GACpD,GAAI,CAkBT,CAEO,OAAAlQ,CACT,CAEO,mBAAyCtB,EAASkJ,EAAiCwG,EAAmB,CACrG,MAAAoC,EAAQ,KAAK,UAAU,MAAM,EACnC/B,EAAiB+B,EAAOpC,CAAM,EAExBoC,EAAA,QAASzF,GAAW,CACnB,KAAA,WAAWrM,EAAMkJ,EAASmD,CAAM,CAAA,CACtC,CACH,CACF,CC9kBA,MAAqB8F,WAA2DvB,EAqBtD,CACxB,aAAc,CACZ,MAAM,SAAS,EAEfvS,KAAmBA,GAAe,mBAAqB,KACzD,CACF,CCxDwB,SAAA+T,GACtB5J,EACA6J,EACAC,EACA,CACM,MAAAC,EAAa,CAACC,EAAiBC,IAAkB,CACrDjK,EAAY,iBAAiBgK,CAAU,EAC3BC,GAAAjK,EAAY,eAAeiK,CAAQ,EAC/CJ,IAAYG,CAAU,CAAA,EAGxBhK,EAAY,oBAAoB8J,CAAY,EAEzC,OAAO,wBAA6B,IACpClU,EAAuC,iBAAiB,UAAY4D,GAAMuQ,EAAWvQ,EAAE,OAAQA,EAAE,MAAM,CAAC,EACjG,OAAO,yBAA8B,IAC7CuQ,EAAWnU,EAAK,IAAI,EAEpBmU,EAAWnU,EAAKA,CAAG,CAEvB,CCLA,MAAMsU,MAA6C,IAC7CC,EAAiB/L,EAAU,SAAS,EACpCgM,GAAgB,GAErB,KAAa,YAAcF,EAI5B,MAAMG,GAAY,CAChB,SAAW3J,GAAY,CACf,KAAA,CAAC,GAAAb,CAAM,EAAAa,EACV,GAAAwJ,EAAY,IAAIrK,CAAE,EACZ,OAAA,QAAQ,OAAOsK,CAAc,EAMtC,MAAMG,EAAW,IAAI,qBAAqB,CAAC,cAAe,CAAE,CAAA,EAQtDxR,EAAUiB,IAChBjB,EAAQ,KAAK,IAAM,CACjB,WAAW,IAAM,CACfoR,EAAY,OAAOrK,CAAE,GACpB,GAAG,CAAA,EACL,IAAM,CACPqK,EAAY,OAAOrK,CAAE,CAAA,CACtB,EAIG,IAAA0K,EACE,MAAAC,EAAW,IAAI,eAAe,CAClC,MAAQC,GAAgB,CACTF,EAAAE,CACf,EAEA,OAASC,GAAW,CAClB5R,EAAQ,OAAOqR,CAAc,CAC/B,GACCG,CAAQ,EAQL7C,EAAqB,CACzB,GAAG/G,EAEH,eAAgB8J,EAIhB,QAAA1R,EACA,WAAAyR,CAAA,EAGU,OAAAL,EAAA,IAAIrK,EAAI4H,CAAI,EAGjB3O,EAAQ,MAAM,IAAM,CAAO,MAAAqR,CAAA,CAAe,CACnD,EAEA,cAAe,CAAC,CAAC,GAAAtK,EAAI,MAAA8K,KAAW,CACxB,MAAAlD,EAAOyC,EAAY,IAAIrK,CAAE,EAC/B,OAAI4H,EAOGA,EAAK,WAAW,QAAQkD,CAAK,EAN3B,QAAQ,QAOnB,EAEA,iBAAmB9K,GAAO,CAClB,MAAA4H,EAAOyC,EAAY,IAAIrK,CAAE,EAC/B,OAAI4H,GAIJA,EAAK,QAAQ,UAGNA,EAAK,WAAW,SANd,QAAQ,QAOnB,EAEA,eAAiB5H,GAAO,CAChB,MAAA4H,EAAOyC,EAAY,IAAIrK,CAAE,EAC/B,GAAI4H,EAIJ,OAAAA,EAAK,QAAQ,SAGNA,EAAK,WAAW,OACzB,CACF,EAEA,SAAwBmD,GAAehK,EAA+C,CACpF,OAAAA,EAAmB,2BAA2ByJ,EAAM,EAE7C,CAAA,gBACLQ,GACA,gBAAiBC,EAAA,CAErB,CAEA,SAASD,GAAgB7R,EAAmBwI,EAAgB,CAC1D,MAAM1I,EAAUP,GAAM,GAAG,EAAE,KAAK,IAAM,CAC9B,MAAAkP,EAAOyC,EAAY,IAAI1I,CAAM,EACnC,GAAG,CAACiG,GAASA,EAAK,MAAQ,CAAC2C,GACzB,OAGF3C,EAAK,KAAO,GACZ,MAAM9F,EAAS8F,EAAK,eAEb,OADU,IAAI,SAAS9F,EAAQ,CAAC,QAAS8F,EAAK,QAAQ,CACtD,CACR,EAEDzO,EAAM,YAAYF,CAAO,CAC3B,CAEA,SAASgS,IAAqB,CAC5B,GAAGZ,EAAY,KACb,SAAU,CAACrK,EAAI4H,CAAI,IAAKyC,EAEtBzC,EAAK,WAAW,OAGtB,CC5JA,MAAMxN,EAAwC,CAAA,EAE9C,SAAS8Q,GAAcC,EAA+B,CAC7C,MAAA,CACL,MAAOA,EAAS,OAAO,OAAO,EAC9B,MAAOA,EAAS,IAAI,OAAO,EAC3B,KAAMA,EAAS,IAAI,MAAM,EACzB,IAAKA,EAAS,IAAI,KAAK,CAAA,CAE3B,CAEA,eAAeC,GAAkBD,EAAoBE,EAAkB,CACjE,GAAA,CACFrT,EAAI,aAAcmT,CAAQ,EACpB,MAAA/E,EAAO8E,GAAcC,CAAQ,GAClC/Q,EAAAiR,KAAAjR,EAAAiR,GAAuB,CAAC,IAAG,KAAKjF,CAAI,QAC/BzP,EAAK,CACPqB,EAAA,KAAK,gCAAiCrB,CAAG,CAC/C,CACF,CAEO,SAAS2U,GAAkCC,EAA4B,CACtE,MAAAlD,EAAMjO,EAASmR,EAAa,EAAE,EAChClD,IAIG,OAAAjO,EAASmR,EAAa,EAAE,EAE/BvT,EAAI,oCAAqCuT,EAAa,GAAI,UAAWlD,EAAI,MAAM,EAC3EA,EAAA,QAASjC,GAAS,CACDrF,EAAA,WAAW,QAASqF,EAAMmF,CAAY,CAAA,CAC1D,EACH,CAEwB,SAAAC,GAAarS,EAAmBwI,EAAgB,CACtE,MAAM1I,EAAUE,EAAM,QAAQ,WAC7B,KAAMgS,IACaC,GAAAD,EAAUhS,EAAM,iBAAiB,EAC5C,SAAS,SAAS,IAAI,EAC9B,EAEDA,EAAM,YAAYF,CAAO,CAC3B,CC5Ba,MAAAjB,EAAMP,EAAO,KAAMN,EAAS,MAAQA,EAAS,MAAQA,EAAS,IAAMA,EAAS,KAAM,EAAI,EAC9FpB,EAAM,KAGZ,IAAI0V,EACG,MAAMvL,GAAwB,IAAMuL,EAE3CzT,EAAI,MAAM,EAEV,MAAM0T,GAAmBrE,GAA4B,CAC7C,MAAAsE,EAAU,IAAI,eACD5K,EAAA,WAAW0K,EAAsBE,EAAQ,KAAK,EACjE5K,EAAmB,WAAW,OAAQ,OAAWsG,EAAQ,CAACsE,EAAQ,KAAK,CAAC,CAC1E,EAEMC,GAA2BvE,GAA4B,CACxD,CAACwE,EAAiB,MAAQ,CAACJ,IAC5BzT,EAAI,kCAAkC,EACtC0T,GAAgBrE,CAAM,EAE1B,EAEMyE,GAAqBzE,GAAyB,CAG/C,GAFHrP,EAAI,mBAAoBqP,EAAO,GAAI,iBAAkBwE,EAAiB,IAAI,EAEvExE,EAAO,YAAc,OAAQ,CAC1BrP,EAAA,KAAK,wCAAyCqP,EAAO,EAAE,EAC3D,MACF,CAEArP,EAAI,UAAW,MAAM,KAAK6T,CAAgB,CAAC,EACxB9K,EAAA,WAAW,QAAS,OAAWsG,CAAM,EACxDuE,GAAwBvE,CAAM,EACbwE,EAAA,IAAIxE,EAAO,GAAIA,CAAM,EAEtCiE,GAAkCjE,CAAM,CAC1C,EAEatG,EAAqB,IAAI+I,GACtC/I,EAAmB,2BAA2B,CAC5C,mBAAoB4F,GAEpB,eAAgB,CAAC,CAAC,QAAA3H,EAAS,WAAAC,KAAgB,CAClBE,EAAA,cAAcH,EAASC,CAAU,CAC1D,EAEA,SAAU,CAAC4B,EAASwG,IAAW,CAC7BD,GAAOvG,EAASwG,CAAM,CACxB,EAEA,MAAO,CAACxG,EAASwG,IAAW,CAC1ByE,GAAkBzE,CAA6B,CACjD,EAEA,kBAAmBC,EACrB,CAAC,EAED,KAAM,CACJ,gBAAA0D,GACA,gBAAiBe,EACnB,EAAIhB,GAAehK,CAAkB,EAGrCxK,KAAmB,KAAMyV,GAAkB,CACrChU,EAAA,OAAOgU,EAAc,MAAM,yBAAyB,EAC1CA,EAAA,QAAST,GAAiB,CACtCO,GAAkBP,CAAY,CAAA,CAC/B,CACH,CAAC,EAED,MAAMM,MAAkD,IACvD,KAAa,iBAAmBA,EACjC9B,GAAkBhJ,EAAoB,OAAYsG,GAAW,CAG3D,GAFArP,EAAI,6BAA8BqP,CAAM,EAErC,EADoBA,aAAkB,eACnB,CAACwE,EAAiB,IAAIxE,EAAO,EAAE,EAAG,CACtDrP,EAAI,KAAK,oBAAoB,EAC7B,MACF,CAEiB6T,EAAA,OAAOxE,EAAO,EAAE,EAC7BrP,EAAA,4BAA6B6T,EAAiB,IAAI,EAClDA,EAAiB,OACnB7T,EAAI,KAAK,iBAAiB,EAEvByT,IACD1K,EAAmB,WAAW0K,CAAmB,EAC3BA,EAAA,QAGAM,KAE5B,CAAC,EAGD,MAAME,GAAW9S,GAA4B,CAC3C,GAEE,CAACjD,IACDiD,EAAM,QAAQ,IAAI,QAAQ,SAAS,OAAS,GAAG,IAAM,GACrDA,EAAM,QAAQ,IAAI,MAAM,kFAAkF,EAE1G,OAAOA,EAAM,YAAYD,GAAaC,CAAK,CAAC,EAO1C,GAAA,CAEI,KAAA,CAAC+S,EAAOC,CAAO,EAAIhT,EAAM,QAAQ,IAAI,MAAM,GAAG,EAAE,MAAM,EAAE,EACxD,CAACwI,EAAQC,CAAM,EAAIuK,EAAQ,MAAM,GAAG,EAI1C,OAAOD,EAAO,CACZ,IAAK,SAAU,CACCxK,GAAAvI,EAAOwI,EAAQC,CAAM,EACnC,KACF,CAEA,IAAK,WAAY,CACfoJ,GAAgB7R,EAAOwI,CAAM,EAC7B,KACF,CAEA,IAAK,QAAS,CACZ6J,GAAarS,EAAOwI,CAAM,EAC1B,KACF,CAEA,IAAK,OAAQ,CACXxI,EAAM,YAAY,IAAI,SAAS,MAAM,CAAC,EACtC,KACF,CAMF,QACMxC,EAAK,CACPqB,EAAA,MAAM,cAAerB,CAAG,EACtBwC,EAAA,YAAY,IAAI,SAAS,GAAI,CACjC,OAAQ,IACR,WAAY,wBACZ,QAAS,CAAC,gBAAiB,UAAU,CACtC,CAAA,CAAC,CACJ,CACF,EAEMiT,GAAgB,IAAM,CAC1BrW,EAAI,QAAUkW,EAChB,EAEAlW,EAAI,iBAAiB,UAAYoD,GAAU,CACzCnB,EAAI,YAAY,EACVmB,EAAA,UAAUpD,EAAI,YAAY,EAAE,KAAK,IAAMiC,EAAI,iBAAiB,CAAC,CAAC,CACtE,CAAC,EAEDjC,EAAI,iBAAiB,WAAaoD,GAAU,CAC1CnB,EAAI,aAAcjC,CAAG,EACfoD,EAAA,UAAUpD,EAAI,OAAO,OAAO8C,EAAiB,EAAE,KAAK,IAAMb,EAAI,sBAAsB,CAAC,CAAC,EACtFmB,EAAA,UAAUpD,EAAI,QAAQ,MAAM,EAAE,KAAK,IAAMiC,EAAI,iBAAiB,CAAC,CAAC,CACxE,CAAC,EAUDjC,EAAI,UAAYA,EAAI,SAAWqW,GAE/BA,GAAc"}